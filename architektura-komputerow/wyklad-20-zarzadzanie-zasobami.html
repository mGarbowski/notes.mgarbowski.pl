<!doctype html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>wyklad-20-zarzadzanie-zasobami</title>
    <link rel="stylesheet" href="../style.css">

    <!--    Load mathjax from cdn to render latex equations-->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
<div class="prev-next-links">
    
    <div class="index-links-prev">
        <a href="wyklad-19-wydajnosc.html">Poprzedni: wyklad-19-wydajnosc.html</a>
    </div>
    

    
    <div class="index-links-next">
        <a href="wyklad-22-wyjatki.html">Następny: wyklad-22-wyjatki.html</a>
    </div>
    
    <div class="return-link">
        <a href="..">Powrót</a>
    </div>
</div>
<div class="container">
    <div class="index-links-wrapper">
        <h2>Architektura komputerów</h2>
        <div class="index-links">
            <ul>
                
                <li><a href="wyklad-01-wstep.html">wyklad-01-wstep.html</a></li>
                
                <li><a href="wyklad-02-klasyfikacja-pamieci.html">wyklad-02-klasyfikacja-pamieci.html</a></li>
                
                <li><a href="wyklad-03-dane-alfanumeryczne.html">wyklad-03-dane-alfanumeryczne.html</a></li>
                
                <li><a href="wyklad-04-reprezentacja-danych-w-pamieci.html">wyklad-04-reprezentacja-danych-w-pamieci.html</a></li>
                
                <li><a href="wyklad-05-programmowy-model-uzytkowy.html">wyklad-05-programmowy-model-uzytkowy.html</a></li>
                
                <li><a href="wyklad-06-wywolania-procedur.html">wyklad-06-wywolania-procedur.html</a></li>
                
                <li><a href="wyklad-07-budowa-modelu-programowego.html">wyklad-07-budowa-modelu-programowego.html</a></li>
                
                <li><a href="wyklad-08-risc-v.html">wyklad-08-risc-v.html</a></li>
                
                <li><a href="wyklad-09-konsolidacja.html">wyklad-09-konsolidacja.html</a></li>
                
                <li><a href="wyklad-10-intel-x86.html">wyklad-10-intel-x86.html</a></li>
                
                <li><a href="wyklad-11-intel-x86.html">wyklad-11-intel-x86.html</a></li>
                
                <li><a href="wyklad-12-intel-x86.html">wyklad-12-intel-x86.html</a></li>
                
                <li><a href="wyklad-13-komputer-jednocyklowy.html">wyklad-13-komputer-jednocyklowy.html</a></li>
                
                <li><a href="wyklad-14-komputer-wielocyklowy.html">wyklad-14-komputer-wielocyklowy.html</a></li>
                
                <li><a href="wyklad-16-potokowe-jednostki-wykonawcze.html">wyklad-16-potokowe-jednostki-wykonawcze.html</a></li>
                
                <li><a href="wyklad-18-kieszenie.html">wyklad-18-kieszenie.html</a></li>
                
                <li><a href="wyklad-19-wydajnosc.html">wyklad-19-wydajnosc.html</a></li>
                
                <li><a href="wyklad-20-zarzadzanie-zasobami.html">wyklad-20-zarzadzanie-zasobami.html</a></li>
                
                <li><a href="wyklad-22-wyjatki.html">wyklad-22-wyjatki.html</a></li>
                
                <li><a href="wyklad-23-wejscie-wyjscie.html">wyklad-23-wejscie-wyjscie.html</a></li>
                
                <li><a href="wyklad-24-budowa-komputera.html">wyklad-24-budowa-komputera.html</a></li>
                
                <li><a href="zadania.html">zadania.html</a></li>
                
            </ul>
        </div>
    </div>
    <div class="content-wrapper">
        <main>
            <h1 id="zarządzanie-zasobami-komputera">Zarządzanie zasobami
komputera</h1>
<p>Współczesne systemy są wieloużytkowe, wieloprocesowe i
wielowątkowe</p>
<p>Procesy nie mogą wzajemnie wpływać na swoje wykonywanie, dane są
izolowane, zakłócenie jesdnego nie zakłóca działania innego procesu ani
systemu operacyjnego</p>
<h2 id="ochrona-zasobów">Ochrona zasobów</h2>
<h3 id="procesor">Procesor</h3>
<ul>
<li>proces nie może zmonopolizować czasu procesora (np. przy
nieskończonej pętli)</li>
<li>inne procesy muszą mieć możliwość wykonywania się</li>
<li>cdn…</li>
</ul>
<h3 id="pamięć">Pamięć</h3>
<ul>
<li>Proces ma dostęp tylko do przydzielonej mu pamięci (i ewentualnie do
danych współdzielonych po uzgodnieniu z innym procesem)</li>
<li>Proces nie może odwołać się do własnej pamięci w niewłaściwy sposób
<ul>
<li>zapis do stałych</li>
<li>zapis do kodu</li>
<li>wykonywanie danych jako kodu</li>
</ul></li>
</ul>
<h2 id="io">IO</h2>
<ul>
<li>Urządzenia IO nie mogą sobie przeszkadzać nawzajem</li>
<li>W praktyce całkowicie uniemożliwia się bezpośrednie odwołania do
urządzeń - wszystkiemu pośredniczy system operacyjny</li>
</ul>
<h2 id="użytkownik-i-system">Użytkownik i system</h2>
<ul>
<li>Żeby zrealizować mechanizmy ochrony trzeba zróżnicować uprawnienia
programów na poziomie sprzętu (conajmniej 2 poziomy)</li>
<li>Proces użytkowy pracuje na poziomie użytkownika</li>
<li>System operacyjny pracuje na poziomie systemowym</li>
<li>Założenie - system operacyjny jest poprawny - nie zawiera błędów,
nie wpadnie w nieskończoną pętle itp.</li>
<li>Założenie - aplikacje nie są zaufane, mogą zawierać błędy a system
operacyjny ma przed tym chronić</li>
</ul>
<h2 id="poziomy-uprzywilejowania">Poziomy uprzywilejowania</h2>
<p>Często wprowadza się trzec</p>
<ul>
<li>jądra systemu</li>
<li>usług systemu</li>
<li>użytkownika</li>
</ul>
<p>Aktualny poziom uprzywilejowana jest przechowywany w procesorze w
systemowym rejestrze stanu</p>
<h2 id="egzekwowanie-zasad-ochrony">Egzekwowanie zasad ochrony</h2>
<p>Naruszenie zasad ochrony jest wykrywane (sprzętowo), blokowane i
zgłaszany jest wyjątek</p>
<p>Sprzętowo przełącza się wykonywanie z wadliwej aplikacji na procedury
systemowe</p>
<h2 id="ochrona-czasu-procesora">Ochrona czasu procesora</h2>
<p>Wątki wykonują się naprzemiennie, wątek musi być możliwy do
przerwania wbrew jego woli.</p>
<p>Timer systemowy zgłasza wyjątek co stały okres - system operacyjny
przejmuje sterowanie</p>
<p>W szczególnych sytuacjach system może zezwolić na wyłączny dostęp
pojedynczego procesu do urządzenia (np. DirectX)</p>
<h2 id="ochrona-pamięci">Ochrona pamięci</h2>
<p>Poprawność musi być zapewniana przez mechanizmy sprzętowe - program
wykonuje się cały czas</p>
<h2 id="maszyny-wirtualne">Maszyny wirtualne</h2>
<p>Jednoczesna praca kilku systemów operacyjynch na jednym
komputerze</p>
<p>Wprowadza się kolejny poziom ochrony - hypervisor</p>
<p>dwa systemy operacyjne muszą być kontrolowane jak aplikacja i
system</p>
<h2 id="strefa-zaufana">Strefa zaufana</h2>
<p>Zabezpieczenie przed instalacją podrobionego systemu operacyjnego -
np. aktualizacje do urządzeń IoT</p>
<h3 id="przestrzeń-uprawnień">Przestrzeń uprawnień</h3>
<ul>
<li>użytkownik-system</li>
<li>system-hypervisor</li>
<li>strefa zaufana - strefa niezaufana</li>
</ul>
<p>Przestrzeń uprwanień może być zrealizowana jednowymiarowo aplikacja,
system, hypervisor, monitor strefy zaufanej</p>
<p>Może być trójwymiarowa - hypervisor/gość, aplikacja/system,
zaufany/niezaufany</p>
<h1 id="funkcje-systemu-zarządzani-pamięcią">Funkcje systemu zarządzani
pamięcią</h1>
<p>Wykuć na pamięć!!!!!</p>
<ol type="1">
<li>Sprzętowa relokacja - translacja adresów - ten sam adres w dwóch
procesach wykonujących ten sam program z tymi samymi zahardkodowanymi
zadaniami oznaczają inne fizyczne komórki pamięci i jest to zapewniane
sprzętowo w sposób przezroczysty dla programu</li>
<li>Ochrona</li>
<li>Dynamiczna alokacja i dealokacja - powiększenie zmniejszenie
rozmiaru przestrzeni adresowej w trakcie pracy</li>
<li>Wirtualizacja - uniezaleznienie rozmiaru pamięci dostępnej dla
zadania od fizycznej konfiguracji komputera i aktualnego stopnia
wykorzystania pamięci</li>
</ol>
<h2 id="realizacja-zarządzania-pamięcią">Realizacja zarządzania
pamięcią</h2>
<p>…</p>
<h2 id="jednostka-zarządzania-pamięcią">Jednostka zarządzania
pamięcią</h2>
<p>MMU - Memory Management Unit</p>
<p>Układ pośredniczący między procesorem a pamięcią</p>
<ul>
<li>Adres logiczny (adres wirtualny) z procesora trafia na wejście MMU,
MMU produkuje na wyjściu adres fizyczny komórki w pamięci</li>
<li>Typ odwołania - odczyt instrukcjim odczyt danej, zapis danej, poziom
uprzywilejowania</li>
<li>Błąd</li>
</ul>
<p>Schemat połączenia …</p>
<h2 id="algorytmy-zarządzania-pamięcią">Algorytmy zarządzania
pamięcią</h2>
<h3 id="prosta-relokacja">Prosta relokacja</h3>
<ul>
<li>Przestrzeń adresowa jest jednym ciągłym blokiem</li>
<li>System operacyjny operuje na adresach fizycznych</li>
</ul>
<h2 id="prosta-relokacja-1">Prosta relokacja</h2>
<ul>
<li>rejestr datum</li>
<li>rejestr limit</li>
<li>generacja błędu przy przekroczeniu wartości limit</li>
<li>Oddziela zadania od siebie</li>
<li>Nie chroni zadania samego prze sobą</li>
<li>Dynamiczna alokacja
<ul>
<li>jeśli dalej w pamięci jest pusto to wystarczy zwiększyć limit</li>
<li>jeśli obszar dalej jest zajęty trzeba przenieść segment pamięci tam
gdzie jest wolne miejsce i zmodyfikować datum i limit</li>
<li>po dealokacji zostaje puste miejsce - po zakończeniu wiellu zadań
pamięć ma wiele dziur, nie ma dużego wolnego fragmentu - fragmentacja
pamięci</li>
<li>defragmentacja - przepisanie bloków zadań po kolei (zsunięcie) przez
system operacyjny - na końcu pamięci zostaje duży ciągły obszar wolnej
pamięci</li>
</ul></li>
</ul>
<h2 id="segmentacja">Segmentacja</h2>
<ul>
<li>Uogólnienie prostej relokacji</li>
<li>Sekcje kodu, static, sterta i stos są oddzielnie zarządzanymi
segmentami</li>
<li>Można zrobić więcej segmentów niż 4
<ul>
<li>rozdzielenie stałych</li>
<li>pocięcie sekcji TEXT</li>
<li>podział sterty na kawałki</li>
<li>stos musi być jednym segmentem!</li>
</ul></li>
<li>W każdym segmencie adresy są liczone od 0 - adres jest parą
(identyfikator segmentu, adres wewnątrzsegmentowy)
<ul>
<li>na wyjściu jednostki segmentacji - adres liniowy</li>
</ul></li>
<li>Deskryptor segmentu
<ul>
<li>znacznik ważności (1 bit)</li>
<li>prawa dostępu do segmentu (poziom uprzywilejowania)</li>
<li>rozmiar segmentu</li>
<li>liniowy adres bazowy segmentu</li>
<li>trzymany w jednostce segmentacji albo w pamięci</li>
<li>informacje dla jednostki segmentacji</li>
</ul></li>
<li>Jednostka segmentacji wybiera deskryptor na podstawie identyfikatora
segmentu
<ul>
<li>sprawdza ważność</li>
<li>sprawdza uprawnienia</li>
<li>sprawdza czy adres mieści się w zakresie</li>
<li>jeśli nie było błędu to adres wyjściowy = adres bazowy + adres
wewnątrzsegmentowy</li>
</ul></li>
<li>Pojawiają się problemy z fragmentacją - rozszerzenie często wymaga
relokacji</li>
<li>Żeby efektywnie realizować wirtualizację musi być dużo segmentów
<ul>
<li>defragmentacja pamięci jest szybka</li>
<li>defragmentacja dysku jest bardzo wolna</li>
</ul></li>
<li>Generalnie źle działa ale jest używana w x86</li>
</ul>
<h2 id="stronicowanie">Stronicowanie</h2>
<ul>
<li>Metoda wymyślona na potrzeby realizacji wirtualizacji</li>
<li>Bloki o stałej długości 2^n (typowo 4KiB) wyrównane naturalnie -
strony</li>
<li>Strony fizyczne / ramki strony - przestrzeń fizyczna</li>
<li>Strony / strony logiczne / strony wirtualne - przestrzeń
logiczna</li>
<li>Pamięć dla programu zawsze alokuje się w stronach</li>
<li>Marnowanie pamięci na końcu ostatniej strony (fragmentacja
wewnętrzna) - mały problem</li>
</ul>
<h3 id="jednostka-stronicowania">Jednostka stronicowania</h3>
<ul>
<li>Przyporządkowuje strony logiczne do fizycznych</li>
<li>Mniej znaczące bity adresu to adres wewnątrz strony
<ul>
<li>nie wymaga translacji bo jest wyrównanie naturalne</li>
<li>bardziej znaczące bity adresu są adresem strony logicznej</li>
</ul></li>
<li>Sprawdza prawa dostępu, ważność i ewentualnie zwraca błąd</li>
<li>Jeśli nie ma błędu to zwraca adres fizyczny strony (bez operacji
arytmetycznych!)</li>
</ul>
<h3 id="bufor-translacji">Bufor translacji</h3>
<ul>
<li>Różne nazwy
<ul>
<li>TLB (translation lookaside buffer)</li>
<li>TB (translation buffer)</li>
<li>ATC (address translation cache)</li>
</ul></li>
<li>Zrealizowany jako kieszeń pełnoasocjacyjna (albo o wysokiej
asocjacyjności)</li>
<li>Każdy element przechowuje
<ul>
<li>Virtual Page Number</li>
<li>deskryptor strony
<ul>
<li>znacznik wazności (1 bit)</li>
<li>znacznik praw dostępu do strony</li>
<li>fizyczny numer strony</li>
<li>dodatkowe bity atrybutów wykorzystywane przez OS</li>
</ul></li>
</ul></li>
</ul>
<h3 id="chybienie-bufora-translacji">Chybienie bufora translacji</h3>
<ul>
<li>System operacyjny trzyma informacje w pamięci (sprzętowo) -
podejście CISC</li>
<li>Chybienie powoduje wyjątek, system musi załadować deskryptory do
bufora - podejście RISC, mniej wydajne bo programowe</li>
<li>Nie ładuje się nieważnych deskryptorów do bufora</li>
</ul>
<h2 id="pamięć-wirtualna-z-użyciem-stronicowania">Pamięć wirtualna z
użyciem stronicowania</h2>
<ul>
<li>Współpraca dwóch warstw hierarchii pamięci</li>
<li>Takie same rozwiązania jak dla kieszeni L1, L2, L3 można zastosować
do styku pamięci operacyjnej z wirtualną</li>
<li>Zbiór roboczy - zbiór stron
<ul>
<li>część w pamięci operacyjnej</li>
<li>część w pamięci masowej</li>
</ul></li>
<li>Algorytm wyznaczania ofiar - stron zrzucanych do pamięci
wirtualnej</li>
<li>Przerzucanie stron w obie strony</li>
<li>Nie ma problemu fragmentacji przez stały rozmiar stron</li>
</ul>
<h2 id="problem-ze-stronicowaniem">Problem ze stronicowaniem</h2>
<ul>
<li>Typowo w systemach 32-bitowach przestrzeń adresowa była podzielona
na przestrzeń dla użytkownika i dla systemu (po 2 GiB)</li>
<li>Jednostka musi być gotowa z odpowiedzią na każdy dozwolony
adres</li>
<li>Przestrzeń adresowa jest wykorzystana w bardzo małym stopniu (dziura
między stertą i stosem)</li>
<li>Problem rzadkich (sparse) struktur danych</li>
<li>Przechowywanie deskryptora dla każdej strony przestrzeni adresowej
zajmuje 4MiB na każde zadanie - przesada</li>
<li>Stosuje się rozwiązanie tablicowo-drzewiaste (tree of tables)
<ul>
<li>Dla 32-bitowego procesora 2 poziomy</li>
<li>wirtualny adres storny dzieli się na 2 indeksy</li>
<li>pierwszy indeksuje w tablicy głównej tablice podrzędną gdzie jest
deskryptor albo jest pustym wskaźnikiem - błąd</li>
<li>każda tablica zajmuje jedną stronę</li>
</ul></li>
</ul>
<h2 id="problem-z-dwupoziomowymi-tablicami-stron">Problem z
dwupoziomowymi tablicami stron</h2>
<ul>
<li>połowa przestrzeni adresowej każdego zadania jest przeznaczona na
część systemową</li>
<li>ta część - połowa tablic pierwszego rzędu w każdym zadaniu jest taka
sam adla każdego zadania</li>
<li>doalokowanie pamięci przez system przekraczające granicę 4KiB wymaga
kolejnej strony i w każdym zadaniu trzeba odzwiercieglić te zmiany</li>
</ul>
<h2 id="trójpoziomowe-tablice-deskryptorów---tryb-pae">Trójpoziomowe
tablice deskryptorów - tryb PAE</h2>
<ul>
<li>tablica główna umożliwia oddzielenie poddrzewa systemowego od
poddrzewa użytkownika</li>
<li>8-bajtowy deskryptor (x86 w trybie PAE)</li>
<li>Wprowadzono rozróżnienie na odczyt danych i odczyt instrukcji
(odporność na ataki buffer overflow) - flaga no-execute</li>
<li>vpi dzielony na 3 pola - 2b, 9b, 9b
<ul>
<li>tablica 3. poziomu - 4 elementy</li>
<li>tablica 2 - poziomu - maksymalnie 4, 2 dla użytkownika, 2 dla
systemu
<ul>
<li>dla systemu są tworzone tylko raz, sa modyfikowane ale nie zmieniają
położenia, nie są tworzone/usuwane</li>
</ul></li>
</ul></li>
</ul>
<h2 id="stronicowanie-w-procesorze-64-bitowym">Stronicowanie w
procesorze 64-bitowym</h2>
<ul>
<li>Procesor 32-bitowy może wykorzystać mniej niż 4GiB pamięci -
fizyczne zasoby komputera muszą być widoczne dla systemu w pamięci</li>
<li>Zaczęto konstruować 64-bitowe procesory po to żeby wkładać więcej
pamięci</li>
<li>“nikt nigdy nie będzie potrzebował więcej niż 2^64” - może być
uzasadnione (liczba avogadro i masa takiej pamięci)</li>
<li>Realnie adresy są krótsze (np. 48b)</li>
<li>w x86-64 program operuje na adresach od 0 do 2^47 i od
(2<sup>64-2</sup>47) do 2^64</li>
<li>Adres musi mieć na początku albo 17 zer albo 17 jedynek - adresy
kanoniczne</li>
<li>Deskryptory stron wykorzystują tylko 48b adresu</li>
<li>Stosuje się 4-poziomowe tablice</li>
</ul>
<h2 id="chybienie-bufora-translacji-1">Chybienie bufora translacji</h2>
<ul>
<li>Jednostka translacji przeszukuje tablice w poszukiwaniu deskryptora
strony</li>
<li>Traci się czas 4 pełnych dostępów do pamięci</li>
<li>1 chybienie to koszt rzędu czasu 400 instrukcji</li>
<li>Chybienia zdarzają się bardzo rzadko ale powodują bardzo duże
spowolnienie</li>
<li>Chybienia można podizelić na 3 rodzaje
<ul>
<li>chybienia inicjalne - przed pierwszym wypełnieniem bufora - przy
każdym przełączeniu zadania
<ul>
<li>przy przałączaniu zadania wystarczy wymienić deskryptory z dolnej
połowy przestrzeni adresowej (użytkownika)</li>
<li>bit G (global) deskryptora - deskryptor nie jest wyrzucany z bufora
translacji</li>
<li>deskryptorów użytkownika jest na ogół mniej</li>
</ul></li>
<li>chybienia rozmiarowe - wynikające z zapełnienia bufora(konieczności
wyrzucenia elementu)
<ul>
<li>jeśli nie potrzeba wirtualizacji</li>
<li>nie trzeba dzielić pamięci na małe strony</li>
<li>nie potrzeba tak wielu deskryptorów</li>
<li>mniejszy bufor translacji pomieści deskryptory</li>
<li>obszary które nie wymagają wymiany można przechowywać w dużych
megastronach</li>
<li>wirtualizacji nie podlega jądro systemu, i niektóre inne kawałki
systemu</li>
<li>zasoby fizyczne nie wymagają wirtualizacji - zajmują dużą część
przestrzeni adresowej</li>
<li>w x64 tablica 2 lub 3 poziomu może bezpośredni opisywać obszar o
rozmiarze 2MiB albo 1GiB</li>
</ul></li>
<li>chybienia strukturalne - …</li>
</ul></li>
</ul>
<h2 id="poziomowe-tablice-deskryptorów">5-poziomowe tablice
deskryptorów</h2>

        </main>
    </div>
    <div class="table-of-contents">
        <nav id="TOC" role="doc-toc">
<ul>
<li><a href="#zarządzanie-zasobami-komputera" id="toc-zarządzanie-zasobami-komputera">Zarządzanie zasobami
komputera</a>
<ul>
<li><a href="#ochrona-zasobów" id="toc-ochrona-zasobów">Ochrona
zasobów</a>
<ul>
<li><a href="#procesor" id="toc-procesor">Procesor</a></li>
<li><a href="#pamięć" id="toc-pamięć">Pamięć</a></li>
</ul></li>
<li><a href="#io" id="toc-io">IO</a></li>
<li><a href="#użytkownik-i-system" id="toc-użytkownik-i-system">Użytkownik i system</a></li>
<li><a href="#poziomy-uprzywilejowania" id="toc-poziomy-uprzywilejowania">Poziomy uprzywilejowania</a></li>
<li><a href="#egzekwowanie-zasad-ochrony" id="toc-egzekwowanie-zasad-ochrony">Egzekwowanie zasad ochrony</a></li>
<li><a href="#ochrona-czasu-procesora" id="toc-ochrona-czasu-procesora">Ochrona czasu procesora</a></li>
<li><a href="#ochrona-pamięci" id="toc-ochrona-pamięci">Ochrona
pamięci</a></li>
<li><a href="#maszyny-wirtualne" id="toc-maszyny-wirtualne">Maszyny
wirtualne</a></li>
<li><a href="#strefa-zaufana" id="toc-strefa-zaufana">Strefa zaufana</a>
<ul>
<li><a href="#przestrzeń-uprawnień" id="toc-przestrzeń-uprawnień">Przestrzeń uprawnień</a></li>
</ul></li>
</ul></li>
<li><a href="#funkcje-systemu-zarządzani-pamięcią" id="toc-funkcje-systemu-zarządzani-pamięcią">Funkcje systemu zarządzani
pamięcią</a>
<ul>
<li><a href="#realizacja-zarządzania-pamięcią" id="toc-realizacja-zarządzania-pamięcią">Realizacja zarządzania
pamięcią</a></li>
<li><a href="#jednostka-zarządzania-pamięcią" id="toc-jednostka-zarządzania-pamięcią">Jednostka zarządzania
pamięcią</a></li>
<li><a href="#algorytmy-zarządzania-pamięcią" id="toc-algorytmy-zarządzania-pamięcią">Algorytmy zarządzania
pamięcią</a>
<ul>
<li><a href="#prosta-relokacja" id="toc-prosta-relokacja">Prosta
relokacja</a></li>
</ul></li>
<li><a href="#prosta-relokacja-1" id="toc-prosta-relokacja-1">Prosta
relokacja</a></li>
<li><a href="#segmentacja" id="toc-segmentacja">Segmentacja</a></li>
<li><a href="#stronicowanie" id="toc-stronicowanie">Stronicowanie</a>
<ul>
<li><a href="#jednostka-stronicowania" id="toc-jednostka-stronicowania">Jednostka stronicowania</a></li>
<li><a href="#bufor-translacji" id="toc-bufor-translacji">Bufor
translacji</a></li>
<li><a href="#chybienie-bufora-translacji" id="toc-chybienie-bufora-translacji">Chybienie bufora
translacji</a></li>
</ul></li>
<li><a href="#pamięć-wirtualna-z-użyciem-stronicowania" id="toc-pamięć-wirtualna-z-użyciem-stronicowania">Pamięć wirtualna z
użyciem stronicowania</a></li>
<li><a href="#problem-ze-stronicowaniem" id="toc-problem-ze-stronicowaniem">Problem ze stronicowaniem</a></li>
<li><a href="#problem-z-dwupoziomowymi-tablicami-stron" id="toc-problem-z-dwupoziomowymi-tablicami-stron">Problem z
dwupoziomowymi tablicami stron</a></li>
<li><a href="#trójpoziomowe-tablice-deskryptorów---tryb-pae" id="toc-trójpoziomowe-tablice-deskryptorów---tryb-pae">Trójpoziomowe
tablice deskryptorów - tryb PAE</a></li>
<li><a href="#stronicowanie-w-procesorze-64-bitowym" id="toc-stronicowanie-w-procesorze-64-bitowym">Stronicowanie w
procesorze 64-bitowym</a></li>
<li><a href="#chybienie-bufora-translacji-1" id="toc-chybienie-bufora-translacji-1">Chybienie bufora
translacji</a></li>
<li><a href="#poziomowe-tablice-deskryptorów" id="toc-poziomowe-tablice-deskryptorów">5-poziomowe tablice
deskryptorów</a></li>
</ul></li>
</ul>
</nav>
    </div>
</div>
</body>
</html>
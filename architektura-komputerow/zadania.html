<!doctype html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>zadania</title>
    <link rel="stylesheet" href="../style.css">

    <!--    Load mathjax from cdn to render latex equations-->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
<div class="prev-next-links">
    
    <div class="index-links-prev">
        <a href="wyklad-24-budowa-komputera.html">Poprzedni: wyklad-24-budowa-komputera.html</a>
    </div>
    

    
    <div class="return-link">
        <a href="..">Powrót</a>
    </div>
</div>
<div class="container">
    <div class="index-links-wrapper">
        <h2>Architektura komputerów</h2>
        <div class="index-links">
            <ul>
                
                <li><a href="wyklad-01-wstep.html">wyklad-01-wstep.html</a></li>
                
                <li><a href="wyklad-02-klasyfikacja-pamieci.html">wyklad-02-klasyfikacja-pamieci.html</a></li>
                
                <li><a href="wyklad-03-dane-alfanumeryczne.html">wyklad-03-dane-alfanumeryczne.html</a></li>
                
                <li><a href="wyklad-04-reprezentacja-danych-w-pamieci.html">wyklad-04-reprezentacja-danych-w-pamieci.html</a></li>
                
                <li><a href="wyklad-05-programmowy-model-uzytkowy.html">wyklad-05-programmowy-model-uzytkowy.html</a></li>
                
                <li><a href="wyklad-06-wywolania-procedur.html">wyklad-06-wywolania-procedur.html</a></li>
                
                <li><a href="wyklad-07-budowa-modelu-programowego.html">wyklad-07-budowa-modelu-programowego.html</a></li>
                
                <li><a href="wyklad-08-risc-v.html">wyklad-08-risc-v.html</a></li>
                
                <li><a href="wyklad-09-konsolidacja.html">wyklad-09-konsolidacja.html</a></li>
                
                <li><a href="wyklad-10-intel-x86.html">wyklad-10-intel-x86.html</a></li>
                
                <li><a href="wyklad-11-intel-x86.html">wyklad-11-intel-x86.html</a></li>
                
                <li><a href="wyklad-12-intel-x86.html">wyklad-12-intel-x86.html</a></li>
                
                <li><a href="wyklad-13-komputer-jednocyklowy.html">wyklad-13-komputer-jednocyklowy.html</a></li>
                
                <li><a href="wyklad-14-komputer-wielocyklowy.html">wyklad-14-komputer-wielocyklowy.html</a></li>
                
                <li><a href="wyklad-16-potokowe-jednostki-wykonawcze.html">wyklad-16-potokowe-jednostki-wykonawcze.html</a></li>
                
                <li><a href="wyklad-18-kieszenie.html">wyklad-18-kieszenie.html</a></li>
                
                <li><a href="wyklad-19-wydajnosc.html">wyklad-19-wydajnosc.html</a></li>
                
                <li><a href="wyklad-20-zarzadzanie-zasobami.html">wyklad-20-zarzadzanie-zasobami.html</a></li>
                
                <li><a href="wyklad-22-wyjatki.html">wyklad-22-wyjatki.html</a></li>
                
                <li><a href="wyklad-23-wejscie-wyjscie.html">wyklad-23-wejscie-wyjscie.html</a></li>
                
                <li><a href="wyklad-24-budowa-komputera.html">wyklad-24-budowa-komputera.html</a></li>
                
                <li><a href="zadania.html">zadania.html</a></li>
                
            </ul>
        </div>
    </div>
    <div class="content-wrapper">
        <main>
            <p>Jeśli strona była dla Ciebie pomocna, możesz wesprzeć mnie w jej utrzymaniu na <a href="https://buycoffee.to/mgarbowski">buycoffee.to/mgarbowski</a></p>
            <h1 id="zadania-arko">Zadania ARKO</h1>
<h2 id="wprowadzenie">Wprowadzenie</h2>
<h3 id="co-to-jest-bajt">1. Co to jest bajt</h3>
<p>Najmniejsza adresowalna jednostka pamięci w komputerze, najczęściej 8
bitów ale niekoniecznie</p>
<h3
id="dlaczego-do-wyrażania-pojemności-pamięci-operacyjnej-powinno-się-używać-krotności-binarnych-a-nie-dziesiętnych">2.
Dlaczego do wyrażania pojemności pamięci operacyjnej powinno się używać
krotności binarnych, a nie dziesiętnych?</h3>
<p>Ponieważ komputer używa systemu binarnego</p>
<h3
id="dlaczego-zasoby-pamięciowe-współczesnych-komputerów-mają-budowę-hierarchiczną">3.
Dlaczego zasoby pamięciowe współczesnych komputerów mają budowę
hierarchiczną?</h3>
<p>Pamięć nie może być jednocześnie dowolnie duża i dowolnie szybka,
parametry wzajemnie się wykluczają.</p>
<p>Hierarchiczna budowa umożliwia zróżnicowanie tych parametrów tak,
żeby cała hierarchia pamięci była i szybka i pojemna</p>
<h3
id="jaka-jest-ogólna-zasada-przemieszczania-obiektów-pomiędzy-warstwami-hierarchii-pamięci">4.
Jaka jest ogólna zasada przemieszczania obiektów pomiędzy warstwami
hierarchii pamięci?</h3>
<p>Najczęściej używane obiekty są przesuwane jak najwyżej (najszybsza
pamięć) a nieużywane są spychane niżej (wolniejsza pamięć)</p>
<h3
id="jakie-mechanizmy-decydują-o-przemieszczaniu-obiektów-na-stykach-poszczególnych-warstw-hierarchii-pamięci">5.
Jakie mechanizmy decydują o przemieszczaniu obiektów na stykach
poszczególnych warstw hierarchii pamięci?</h3>
<table>
<colgroup>
<col style="width: 46%" />
<col style="width: 53%" />
</colgroup>
<thead>
<tr class="header">
<th>styk</th>
<th>zarządzany przez</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>rejestry-reszta</td>
<td>kompilator lub programista w assemblerze</td>
</tr>
<tr class="even">
<td>cache-pamięć operacyjna</td>
<td>sprzęt</td>
</tr>
<tr class="odd">
<td>pamięć operacyjna-pamięć wirtualna</td>
<td>system operacyjny</td>
</tr>
<tr class="even">
<td>pamięć wirtualna-system plików</td>
<td>użytkownik lub program użytkowy</td>
</tr>
<tr class="odd">
<td>lokalny-zdalny</td>
<td>użytkownik lub program użytkowy</td>
</tr>
</tbody>
</table>
<h3
id="które-dwie-warstwy-hierarchii-pamięci-są-realizowane-przy-użyciu-tej-samej-struktury-i-tego-samego-fizycznego-urządzenia-jakie-jest-to-urządzenie">6.
Które dwie warstwy hierarchii pamięci są realizowane przy użyciu tej
samej struktury i tego samego fizycznego urządzenia? Jakie jest to
urządzenie?</h3>
<p>Pamięć wirtualna i lokalny system plików fizycznie znajdują się na
dysku (HDD/SSD)</p>
<h3
id="czym-w-taksonomii-skillicorna-różni-się-połączenie-procesora-instrukcji-z-hierarchią-pamięci-instrukcji-od-połączenia-procesora-danych-z-hierarchią-pamięci-danych">7.
Czym w taksonomii Skillicorna różni się połączenie procesora instrukcji
z hierarchią pamięci instrukcji od połączenia procesora danych z
hierarchią pamięci danych?</h3>
<ul>
<li>procesor instrukcji - hierarchia pamięci instrukcji
<ul>
<li>przepływ jednokierunkowy</li>
<li>procesor wysyła żądanie pobrania instrukcji</li>
<li>hierarchia pamięci zwraca instrukcję</li>
</ul></li>
<li>procesor danych - hierarchia pamięci danych
<ul>
<li>przepływ jednokierunkowy -&gt; procesor wysyła żądanie zapisu /
odczytu</li>
<li>przepływ dwukierunkowy -&gt; zapis / odczyt danych</li>
</ul></li>
</ul>
<h3
id="czym-różni-się-silne-od-słabego-sprzężenia-procesorów-w-taksonomii-skillicorna">8.
Czym różni się „silne” od „słabego” sprzężenia procesorów w taksonomii
Skillicorna?</h3>
<ul>
<li>słabe sprzężenie - każdy procesor ma swoją hierarchię pamięci,
procesory komunikują się przez odrębny kanał</li>
<li>silne sprzężenie - wspólna hierarchia pamięci używana przez
wszystkie procesory</li>
</ul>
<h3
id="dlaczego-w-architekturze-harvard-nie-można-wprowadzić-nowego-programu-w-czasie-pracy-komputera">9.
Dlaczego w architekturze Harvard nie można wprowadzić nowego programu w
czasie pracy komputera?</h3>
<p>W architekturze Harvard dane i instrukcje są przechowywane w
oddzielnych hierarchiach pamięci, instrukcje mogą być tylko odczytywane
więc niemożliwe jest zmodyfikowanie programu</p>
<h3 id="na-czym-polega-wąskie-gardło-w-architekturze-princeton">10. Na
czym polega „wąskie gardło” w architekturze Princeton?</h3>
<p>Ponieważ instrukcje i dane są przechowywane w tej samej pamięci, w
danym momencie procesor może albo pobierać instrukcje albo operować na
danych</p>
<h3
id="dlaczego-w-architekturze-harvard-princeton-nie-jest-możliwa-automodyfikacja-programu">11.
Dlaczego w architekturze Harvard-Princeton nie jest możliwa
automodyfikacja programu?</h3>
<p>Górne warstwy hierarchii pamięci (cache) instrukcji i danych są od
siebie oddzielone. Program użytkowy nie ma kontroli nad położeniem
obiektów w hierarchii pamięci więc nie może dokonać automodyfikacji</p>
<h2 id="reprezentacje-danych">Reprezentacje danych</h2>
<h3
id="jaką-wagę-ma-najbardziej-znaczący-bit-16-bitowej-liczby-zapisanej-w-kodzie-u2">12.
Jaką wagę ma najbardziej znaczący bit 16-bitowej liczby zapisanej w
kodzie U2?</h3>
<p>-(2^15)</p>
<h3
id="podać-postaci-binarne-słów-8-bitowych-reprezentujących-liczby-całkowite--120--64--21--10--5-i--1-w-kodach-u2-znak-moduł-i-spolaryzowanym-o-wartości-podkładu-127.">13.
Podać postaci binarne słów 8-bitowych reprezentujących liczby całkowite
-120, -64, -21, -10, -5 i -1 w kodach U2, znak-moduł i spolaryzowanym o
wartości podkładu 127.</h3>
<h3
id="dlaczego-w-zapisie-liczb-zmiennopozycyjnych-ieee754-nie-ma-potrzeby-przechowywania-części-całkowitej-części-znaczącej-liczby">14.
Dlaczego w zapisie liczb zmiennopozycyjnych IEEE754 nie ma potrzeby
przechowywania części całkowitej części znaczącej liczby?</h3>
<p>W zapisie IEEE754 część całkowita wynosi domyślnie 1 więc nie ma
potrzeby jej zapamiętywać</p>
<h3
id="podać-postaci-binarne-słów-32-bitowych-reprezentujących-liczby--256--19--10.125--0.75-0.625-10-15.5-16.5-w-zapisie-zmiennopozycyjnym-ieee-binary32.">15.
Podać postaci binarne słów 32-bitowych reprezentujących liczby -256,
-19, -10.125, -0.75, 0.625, 10, 15.5, 16.5 w zapisie zmiennopozycyjnym
IEEE binary32.</h3>
<h3
id="w-jaki-sposób-można-zmienić-znak-liczby-zapisanej-w-kodzie-u2-używając-wyłącznie-jednoargumentowych-operacji-logicznych-i-arytmetycznych">16.
W jaki sposób można zmienić znak liczby zapisanej w kodzie U2 używając
wyłącznie jednoargumentowych operacji logicznych i arytmetycznych?</h3>
<p>Zanegować wszystkie bity i dodać 1</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="bu">not</span> <span class="kw">eax</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="bu">inc</span> <span class="kw">eax</span></span></code></pre></div>
<h3
id="w-jaki-sposób-wykrywa-się-nadmiar-podczas-dodawania-liczb-w-kodzie-nkb-a-jak-podczas-dodawania-liczb-w-kodzie-u2">17.
W jaki sposób wykrywa się nadmiar podczas dodawania liczb w kodzie NKB,
a jak podczas dodawania liczb w kodzie U2?</h3>
<ul>
<li>NKB - przeniesienie z najbardziej znaczącego bitu</li>
<li>U2 - XOR najbardziej znaczącego bitu i przeniesienia ### 18. Na czym
polega naturalne wyrównanie danych?</li>
<li>Dana w pamięci musi być zapisana pod adresem, który jest podzielny
przez jej rozmiar</li>
<li>Dostęp do danych jest najszybszy kiedy zajmują jak najmniej słów w
pamięci</li>
<li>1 słowo pamięci - 1 przesłanie</li>
<li>Wyrównanie naturalne zapewnia najszybszy możliwy dostęp niezależnie
od długości słowa w pamięci</li>
</ul>
<h3
id="narysować-układ-pól-struktury-o-podanej-deklaracji-w-języku-c-i-określić-wartość-operatora-sizeof-dla-tej-struktury-przyjmując-naturalne-rozmiary-typów-dla-32-bitowego-procesora-z-8-bitowymi-bajtami.-poprawność-rozwiązania-można-sprawdzić-pisząc-program-w-języku-c-wyświetlający-wartości-sizeof-dla-struktury-i-offsetof-dla-poszczególnych-jej-pól">19.
Narysować układ pól struktury o podanej deklaracji w języku C i określić
wartość operatora sizeof dla tej struktury, przyjmując naturalne
rozmiary typów dla 32-bitowego procesora z 8-bitowymi bajtami.
(Poprawność rozwiązania można sprawdzić pisząc program w języku C
wyświetlający wartości sizeof dla struktury i offsetof dla
poszczególnych jej pól)</h3>
<h3
id="dla-podanej-deklaracji-struktury-w-języku-c-podać-wartość-operatora-offsetof-przemieszczenie-pola-struktury-względem-początku-struktury-przyjmując-naturalne-rozmiary-typów-dla-32-bitowego-procesora-z-8-bitowymi-bajtami.-poprawność-rozwiązania-można-sprawdzić-pisząc-program-w-języku-c-wyświetlający-wartości-sizeof-dla-struktury-i-offsetof-dla-poszczególnych-jej-pól.">20.
Dla podanej deklaracji struktury w języku C podać wartość operatora
offsetof – przemieszczenie pola struktury względem początku struktury,
przyjmując naturalne rozmiary typów dla 32-bitowego procesora z
8-bitowymi bajtami. (Poprawność rozwiązania można sprawdzić pisząc
program w języku C wyświetlający wartości sizeof dla struktury i
offsetof dla poszczególnych jej pól).</h3>
<h3
id="naszkicować-orientacyjną-mapę-przestrzeni-adresowej-procesu-użytkowego-w-kilku-systemach-operacyjnych-na-podstawie-wartości-adresów-obiektów-należących-do-różnych-sekcji-wyświetlanych-przez-program-napisany-w-języku-c.">21.
Naszkicować orientacyjną mapę przestrzeni adresowej procesu użytkowego w
kilku systemach operacyjnych na podstawie wartości adresów obiektów
należących do różnych sekcji, wyświetlanych przez program napisany w
języku C.</h3>
<h3
id="na-podstawie-mapy-z-poprzedniego-zadania-oszacować-czy-dany-system-operacyjny-narzuca-istotne-ograniczenie-na-rozmiar-sterty-i-stosu-wynikające-z-samych-wartości-adresów-poszczególnych-sekcji.">22.
Na podstawie mapy z poprzedniego zadania oszacować, czy dany system
operacyjny narzuca istotne ograniczenie na rozmiar sterty i stosu,
wynikające z samych wartości adresów poszczególnych sekcji.</h3>
<h3
id="znając-wartość-danej-32-bitowej-oraz-jej-adres-określić-adresy-i-wartości-poszczególnych-jej-bajtów-przy-konwencji-adresowania-little-endian-i-big-endian">23.
Znając wartość danej 32-bitowej oraz jej adres określić adresy i
wartości poszczególnych jej bajtów przy konwencji adresowania
little-endian i big-endian</h3>
<h2 id="użytkowy-model-programowy">Użytkowy model programowy</h2>
<h3
id="co-wskazuje-rejestr-pc-podczas-wykonywania-instrukcji-po-jej-pobraniu">24.
Co wskazuje rejestr PC podczas wykonywania instrukcji (po jej
pobraniu)?</h3>
<ul>
<li>Adres następnej instrukcji w pamięci - nextPC, w sekcji TEXT</li>
<li>W przypadku skoku jest ładowany adresem docelowym</li>
<li>Inkrementowany podczas pobierania instrukcji tak, że kiedy
instrukcja się wykonuje to PC wskazuje na następną</li>
</ul>
<h3
id="wymienić-i-scharakteryzować-sekcje-pamięci-programu-jednowątkowego-czas-życia-rozmiar-stałyzmienny-zawartość.">25.
Wymienić i scharakteryzować sekcje pamięci programu jednowątkowego (czas
życia, rozmiar stały/zmienny, zawartość).</h3>
<ul>
<li>Kod (TEXT)
<ul>
<li>zawiera instrukcje programu</li>
<li>może zawierać stałe dane - tabele dla <code>switch</code>,
literały</li>
<li>statyczny - obecny w pamięci przez cały czas życia programu</li>
<li>tylko do odczytu</li>
<li>adresy określone przed uruchomieniem programu (najpóźniej podczas
ładowania do pamięci)</li>
</ul></li>
<li>Dane statyczne (STATIC)
<ul>
<li>stałe (RODATA)</li>
<li>zmienne zainicjowane (DATA)</li>
<li>zmienne niezainicjowane (BSS)
<ul>
<li>zerowane na początku</li>
</ul></li>
<li>czas życia równy czasowi życia programu</li>
<li>stały rozmiar</li>
<li>adresy określane przed uruchomieniem programu</li>
</ul></li>
<li>Dane dynamiczne automatyczne (STACK)
<ul>
<li>stos</li>
<li>argumenty i zmienne lokalne procedur</li>
<li>zmienny rozmiar, tworzone i usuwane w trakcie działania
programu</li>
<li>kolejność usuwania odwrotna do kolejności tworzenia</li>
<li>oddzielne dla każdego wątku</li>
<li>położenie określone przed uruchomieniem wątku</li>
</ul></li>
<li>Dane dynamiczne kontrolowane (HEAP)
<ul>
<li>sterta</li>
<li>tworzone i usuwane jawnie przez programistę (<code>malloc</code>,
<code>free</code>)</li>
<li>czas życia nie jest związany z zakończeniem procedur</li>
<li>dowolna kolejność tworzenia i usuwania</li>
<li>alokowane przez procedury biblioteki standardowej języka, która
korzysta z funkcji systemowych</li>
<li>przypisanie adresów w chwili tworzenia</li>
<li><h3
id="jakie-dodatkowe-sekcje-pamięci-muszą-a-jakie-mogą-występować-w-programach-wielowątkowych">26.
Jakie dodatkowe sekcje pamięci muszą, a jakie mogą występować w
programach wielowątkowych?</h3></li>
</ul></li>
<li>Każdy wątek musi mieć własny stos</li>
<li>Opcjonalnie wątki mogą mieć własne dane statyczne
<ul>
<li>zainicjowane (TDATA)</li>
<li>niezainicjowane (TBSS)</li>
</ul></li>
</ul>
<h3
id="opisać-czynności-wykonywane-kolejno-przez-procesor-podczas-wykonania-instrukcji-push-i-pop-na-stosie-pełnym-schodzącym.">27.
Opisać czynności wykonywane kolejno przez procesor podczas wykonania
instrukcji PUSH i POP na stosie „pełnym schodzącym”.</h3>
<ul>
<li>pełny - wskaźnik stosu wskazuje na ostatnio dodaną wartość</li>
<li>schodzący - rośnie w storne niższych adresów</li>
<li>PUSH
<ul>
<li>dekrementacja wskaźnika stosu</li>
<li>składowanie danej pod adresem wierzchołka stosu</li>
</ul></li>
<li>POP
<ul>
<li>załadowanie danej z wierzchołka stosu</li>
<li>inkrementacja wskaźnika stosu</li>
</ul></li>
</ul>
<h3
id="opisać-czynności-wykonywane-kolejno-przez-procesor-podczas-wykonania-instrukcji-push-i-pop-na-stosie-pustym-wchodzącym.">28.
Opisać czynności wykonywane kolejno przez procesor podczas wykonania
instrukcji PUSH i POP na stosie „pustym wchodzącym”.</h3>
<ul>
<li>pusty - wskaźnik stosu wskazuje na następną wolną komórkę pamięci
(?)</li>
<li>wchodzący - rośnie w stronę większych adresów (?)</li>
<li>PUSH
<ul>
<li>składowanie danej pod adresem aktualnego wierzchołka stosu</li>
<li>inkrementacja wierzchołka stosu</li>
</ul></li>
<li>POP
<ul>
<li>dekrementacja wierchołka stosu</li>
<li>ładowanie danej spod adresu aktualnego wskaźnika stosu</li>
</ul></li>
</ul>
<h3
id="znając-wartość-danej-32-bitowej-oraz-wartość-początkową-wskaźnika-stosu-określić-adresy-i-wartości-poszczególnych-jej-bajtów-po-umieszczeniu-jej-na-stosie-pełnym-schodzącym-przez-procesor-działający-w-konwencji-little-endian.">29.
Znając wartość danej 32-bitowej oraz wartość początkową wskaźnika stosu
określić adresy i wartości poszczególnych jej bajtów po umieszczeniu jej
na stosie „pełnym schodzącym” przez procesor działający w konwencji
little-endian.</h3>
<h3 id="na-czym-polega-wykonanie-instrukcji-skoku-ze-śladem">30. Na czym
polega wykonanie instrukcji skoku ze śladem?</h3>
<p>Zapamiętanie wartości nextPC w rejestrze i załadowanie adresu skoku
do PC</p>
<h3
id="jakie-instrukcje-procesora-są-używane-przez-kompilator-do-dzielenia-przez-potęgi-dwójki-liczbzapisanych-w-kodzie-ankb-bu2">31.
Jakie instrukcje procesora są używane przez kompilator do dzielenia
przez potęgi dwójki liczbzapisanych w kodzie (a)NKB (b)U2?</h3>
<ul>
<li>NKB - SHR - przesunięcie logiczne w prawo</li>
<li>U2 - SAR - przesunięcie arytmetyczne w prawo</li>
</ul>
<h3
id="podać-wartość-dziesiętną-liczby-w-kodzie-u2-która-jest-wynikiem-wykonania-na-podanej-liczbie-np.--66--12-130-zapisanej-w-u2-operacji-przesunięcia-o-jeden-bit-a-logicznego-wlewo-b-logicznego-w-prawo-c-arytmetycznego-w-prawo.">32.
Podać wartość dziesiętną liczby w kodzie U2, która jest wynikiem
wykonania na podanej liczbie (np. -66, -12, 130) zapisanej w U2 operacji
przesunięcia o jeden bit (a) logicznego wlewo, (b) logicznego w prawo,
(c) arytmetycznego w prawo.</h3>
<h3
id="czym-różni-się-instrukcja-x86-sub-odejmowanie-od-cmp-porównanie">33.
Czym różni się instrukcja x86 SUB (odejmowanie) od CMP
(porównanie)?</h3>
<p><code>CMP</code> nie zapisuje nigdzie wyniku, tylko ustawia znaczniki
(do późniejszego wykorzystania np przy skoku warunkowym)</p>
<h3
id="dlaczego-adresowanie-ramki-stosu-przy-użyciu-wskaźnika-ramki-jest-na-ogół-wygodniejsze-niż-przy-użyciu-wskaźnika-stosu">34.
Dlaczego adresowanie ramki stosu przy użyciu wskaźnika ramki jest na
ogół wygodniejsze, niż przy użyciu wskaźnika stosu?</h3>
<ul>
<li>Jest wygodniejsze, ponieważ procedura może operować na wskaźniku
stosu więc zmienają się offsety pod jakimi znajdują się zmienne
(względem SP)</li>
<li>Wskaźnik ramki stosu nie zmienia się w trakcie wykonywania ciała
procedury więc offsety są stałe</li>
</ul>
<h3
id="narysować-ramkę-stosu-funkcji-o-podanej-deklaracji-zgodnie-z-konwencją-wołania-x86-oraz-określić-adresy-argumentów-i-prawdopodobne-adresy-zmiennych-lokalnych-zakładając-że-obiekty-w-ramce-stosu-są-adresowane-względem-wskaźnika-ramki">35.
Narysować ramkę stosu funkcji o podanej deklaracji zgodnie z konwencją
wołania x86 oraz określić adresy argumentów i prawdopodobne adresy
zmiennych lokalnych, zakładając, że obiekty w ramce stosu są adresowane
względem wskaźnika ramki</h3>
<h3
id="jakie-tryby-adresowania-są-niezbędne-do-implementacji-języka-wysokiego-poziomu">36.
Jakie tryby adresowania są niezbędne do implementacji języka wysokiego
poziomu?</h3>
<ul>
<li>Rejestrowy bezpośredni <code>mov eax, ebx</code></li>
<li>Natychmiastowy <code>mov eax, 123</code></li>
<li>Jeden z trybów rejestrowych pośrednich
<ul>
<li>np. rejestrowy pośredni z przemieszczeniem
<code>mov eax, [esp-8]</code></li>
</ul></li>
</ul>
<h3
id="określić-nazwy-trybów-adresowania-argumentów-podanej-instrukcji-asemblerowej-x86.">37.
Określić nazwy trybów adresowania argumentów podanej instrukcji
asemblerowej x86.</h3>
<table>
<thead>
<tr class="header">
<th>Tryb adresowania</th>
<th>instrukcja</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Rejestrowy bezpośredni</td>
<td><code>mov eax, ebx</code></td>
</tr>
<tr class="even">
<td>Natychmisatowy</td>
<td><code>mov eax, 123</code></td>
</tr>
<tr class="odd">
<td>Rejestrowy pośredni prosty</td>
<td><code>mov eax, [ebx]</code></td>
</tr>
<tr class="even">
<td>Rejestrowy pośredni z przemieszczeniem</td>
<td><code>mov eax, [ebx+4]</code></td>
</tr>
<tr class="odd">
<td>Dwurejestrowy pośredni</td>
<td><code>mov eax, [ebx+ecx]</code></td>
</tr>
<tr class="even">
<td>Absolutny</td>
<td><code>mov eax, [x]</code></td>
</tr>
<tr class="odd">
<td>Indeksowy</td>
<td><code>mov eax, [ebx + ecx*4]</code></td>
</tr>
</tbody>
</table>
<h3 id="jaką-informację-przechowuje-znacznik-parzystości">38. Jaką
informację przechowuje znacznik parzystości?</h3>
<p>Czy liczba jedynek w najmniej znaczącym bajcie wyniku operacji jest
parzysta</p>
<h3
id="podać-wartości-znaczników-x86-po-wykonaniu-instrukcji-dodawaniaodejmowaniaoperacji-logicznej-o-podanych-wartościach-i-długości-argumentówwyniku.">39.
Podać wartości znaczników x86 po wykonaniu instrukcji
dodawania/odejmowania/operacji logicznej o podanych wartościach i
długości argumentów/wyniku.</h3>
<ul>
<li>ZF - czy wynik operacji wynosi 0</li>
<li>SF - kopia najbardziej znaczącego bitu wyniku</li>
<li>CF - przeniesienie wychodzące z najbardziej znaczącego bitu wyniku
(nadmiar dla liczb be znaku)</li>
<li>OF - czy wystąpił nadmiar w kodzie U2</li>
<li>AF - przeniesienie pomocnicze BCD</li>
<li>PF - czy w najmniej znaczącym bajcie wyniku operacji jest parzysta
liczba jedynek</li>
</ul>
<h3
id="na-czym-polega-ortogonalność-instrukcji-względem-trybów-adresowania">40.
Na czym polega ortogonalność instrukcji względem trybów
adresowania?</h3>
<p>W każdej instrukcji można użyć każdego trybu adresowania</p>
<h3
id="do-jakich-celów-kompilatory-języków-wysokiego-poziomu-używają-rejestrów-w-typowych-architekturach-cisc-a-do-jakich-w-risc">41.
Do jakich celów kompilatory języków wysokiego poziomu używają rejestrów
w typowych architekturach CISC, a do jakich w RISC?</h3>
<ul>
<li>CISC
<ul>
<li>wykonywanie obliczeń</li>
<li>przechowywanie wyników pośrednich</li>
<li>typowo mała liczba rejestrów nie umożliwia przekazywania argumentów
i zwracania wyników przez rejestry</li>
</ul></li>
<li>RISC
<ul>
<li>przekazywanie argumentów (skalarnych) do procedur</li>
<li>przechowywanie zmiennych lokalnych (skalarnych)</li>
<li>znaczne ograniczenie liczby odwołań do pamięci i przyspieszenie
kodu</li>
<li>typowo duża liczba rejestrów umożliwia ograniczenie odwołań do
pamięci</li>
</ul></li>
</ul>
<h3
id="dlaczego-programy-dla-procesorów-risc-na-ogół-zajmują-w-pamięci-więcej-miejsca-niż-równoważne-im-programy-dla-procesorów-cisc">42.
Dlaczego programy dla procesorów RISC na ogół zajmują w pamięci więcej
miejsca niż równoważne im programy dla procesorów CISC?</h3>
<ul>
<li>Instrukcje RISC mają stałą długość, często większą niż średnia
długość instrukcji dla programu CISC</li>
<li>Operację równoważną jednej instrukcji CISC często wymaga kilku
instrukcji RISC</li>
</ul>
<h3
id="dlaczego-procesory-risc-nie-mają-zwykle-instrukcji-ładowania-do-rejestru-32-bitowej-danej-natychmiastowej-w-jaki-inny-sposób-może-być-zrealizowana-ta-operacja">43.
Dlaczego procesory RISC nie mają zwykle instrukcji ładowania do rejestru
32-bitowej danej natychmiastowej? W jaki inny sposób może być
zrealizowana ta operacja?</h3>
<ul>
<li>Długość instrukcji jest stała, kiedy wynosi 32 bity to nie zmieści
całej stałej 32-bitowej</li>
<li>Można załadować 32-bitową daną natychmiastową używając dwóch
instrukcji
<ul>
<li><code>li</code> - load immediate najmniej znaczące 12 bitów</li>
<li><code>lui</code> - load upper immediate, bardziej znaczące 20
bitów</li>
</ul></li>
<li>Można umieścić ją w pamięci jako daną statyczną</li>
</ul>
<h3
id="dlaczego-w-architekturach-risc-na-ogół-nie-występuje-instrukcja-powrotu-z-procedury-jaka-instrukcja-jest-używana-w-tych-architekturach-do-powrotu-z-procedur">44.
Dlaczego w architekturach RISC na ogół nie występuje instrukcja powrotu
z procedury? Jaka instrukcja jest używana w tych architekturach do
powrotu z procedur?</h3>
<h3
id="dlaczego-w-architekturze-risc-v-nie-ma-instrukcji-subi-odejmowania-stałej-natychmiastowej-bez-pułapki-przy-nadmiarze">45.
Dlaczego w architekturze RISC-V nie ma instrukcji SUBI – odejmowania
stałej natychmiastowej bez pułapki przy nadmiarze?</h3>
<h3
id="wymienić-nazwy-rejestrów-x86-w-trybie-32-bitowym-i-podać-funkcje-rejestrów-które-mają-sztywno-przypisane-zastosowanie.">46.
Wymienić nazwy rejestrów x86 (w trybie 32-bitowym) i podać funkcje
rejestrów, które mają sztywno przypisane zastosowanie.</h3>
<ul>
<li>32-bitowe
<ul>
<li>EAX - główny akumulator</li>
<li>ECX - licznik iteracji</li>
<li>EDX - dzielna / iloczyn (w mnożeniu/dzieleniu
jednoargumentowym)</li>
<li>EBX</li>
<li>ESP - wskaźnik stosu</li>
<li>EBP - wskaźnik ramki</li>
<li>ESI - wskaźnik źródła (do instrukcji iteracyjnych)</li>
<li>EDI - wskaźnik przeznaczenia (do instrukcji iteracyjnych)</li>
<li>EFLAGS - rejestr stanu</li>
<li>EIP - licznik instrukcji</li>
</ul></li>
<li>16-bitowe
<ul>
<li>AX</li>
<li>CX</li>
<li>DX</li>
<li>BX</li>
<li>SP</li>
<li>BP</li>
<li>SI</li>
<li>DI</li>
</ul></li>
<li>8-bitowe
<ul>
<li>AH, AL</li>
<li>CH, CL</li>
<li>DH, DL</li>
<li>Bh, BL</li>
</ul></li>
</ul>
<h3
id="jaka-instrukcja-procesorów-x86-służy-do-szybkiego-mnożenia-liczb-całkowitych-przez-3-5-i-9">47.
Jaka instrukcja procesorów x86 służy do szybkiego mnożenia liczb
całkowitych przez 3, 5 i 9?</h3>
<p><code>LEA</code></p>
<h3
id="jaki-częsty-błąd-programisty-popełniany-przy-programowaniu-asemblerowym-powoduje-sygnalizację-nadmiaru-dzielenia-w-procesorze-x86">48.
Jaki częsty błąd programisty, popełniany przy programowaniu
asemblerowym, powoduje sygnalizację nadmiaru dzielenia w procesorze
x86?</h3>
<p>Nie rozszerzenie dzielnej (zerowanie rejestru edx lub dopełnienie
bitem znaku)</p>
<h3
id="w-jakim-celu-w-jednostkach-wektorowych-wprowadzono-instrukcję-iloczynu-logicznego-z-negacją-jednego-z-argumentów">49.
W jakim celu w jednostkach wektorowych wprowadzono instrukcję iloczynu
logicznego z negacją jednego z argumentów?</h3>
<ul>
<li>Dla umożliwienia realizacji przypisania trójargumentowego
<code>x = cond ? a : b</code></li>
<li>Oblicza się wynik <code>a</code> dla <code>cond == true</code></li>
<li>Oblicza się wynik <code>b</code> dla <code>cond == false</code></li>
<li>Oblicza się maskę warunku - same <code>1</code> w miejscu elementu
wektora, który spełnia warunek</li>
<li>Sumuje się iloczyn maski z <code>a</code> z iloczynem zanegowanej
maski z <code>b</code> - po to jest operacja <code>ANDN</code></li>
</ul>
<h3
id="jaką-postać-ma-wynik-instrukcji-porównania-danych-wykonywanej-przez-jednostkę-wektorową">50.
Jaką postać ma wynik instrukcji porównania danych wykonywanej przez
jednostkę wektorową?</h3>
<ul>
<li>Ma postać maski bitowej</li>
<li>Ta sama długość co wektor argumentu</li>
<li>Zawiera same <code>1</code> na miejscach elementów wektora, które
spełniają warunek i same <code>0</code> na miejscach elementów które nie
spełniają</li>
</ul>
<h3
id="instrukcja-pcmpeqb-jednostki-wektorowej-mmx-porównuje-dwa-64-bitowe-wektory-8-bitowych-liczb-całkowitych.-określić-wartość-wyniku-tej-instrukcji-dla-argumentów-źródłowych-0x11222334455667788-i-0x1111444466667777.">51.
Instrukcja PCMPEQB jednostki wektorowej MMX porównuje dwa 64-bitowe
wektory 8-bitowych liczb całkowitych. Określić wartość wyniku tej
instrukcji dla argumentów źródłowych 0x11222334455667788 i
0x1111444466667777.</h3>
<p>0x1100001100111100</p>
<table>
<tbody>
<tr class="odd">
<td>v1</td>
<td>11</td>
<td>22</td>
<td>33</td>
<td>44</td>
<td>55</td>
<td>66</td>
<td>77</td>
<td>88</td>
</tr>
<tr class="even">
<td>v2</td>
<td>11</td>
<td>11</td>
<td>44</td>
<td>44</td>
<td>66</td>
<td>66</td>
<td>77</td>
<td>77</td>
</tr>
<tr class="odd">
<td>v1 == v2</td>
<td>11</td>
<td>00</td>
<td>00</td>
<td>11</td>
<td>00</td>
<td>11</td>
<td>11</td>
<td>00</td>
</tr>
</tbody>
</table>
<h3
id="czym-różni-się-w-zapisie-binarnym-i-wykonaniu-instrukcja-skoku-względnego-zwykle-określana-jako-branch-od-instrukcji-skoku-bezwzględnego-zwykle-nazywanej-jump">52.
Czym różni się w zapisie binarnym i wykonaniu instrukcja skoku
względnego (zwykle określana jako branch) od instrukcji skoku
bezwzględnego (zwykle nazywanej jump)?</h3>
<ul>
<li>skok względny (branch) - w instrukcji zapisane jest przemieszczenie
skoku - liczba dodawana do nextPC</li>
<li>skok bezwzględny (jump) - w instrukcji zapisany jest absolutny adres
- liczba ładowana do PC</li>
</ul>
<h3
id="w-jaki-sposób-kończy-się-wykonanie-programu-działającego-pod-kontrolą-systemu-operacyjnego-skąd-system-operacyjny-wie-która-instrukcja-programu-jest-ostatnią">53.
W jaki sposób kończy się wykonanie programu działającego pod kontrolą
systemu operacyjnego – skąd system operacyjny wie, która instrukcja
programu jest ostatnią</h3>
<p>Program kończy się wywołaniem odpowiedniej procedury systemowej
(<code>exit</code>) (?)</p>
<h2 id="jednostka-wykonawcza-procesora">Jednostka wykonawcza
procesora</h2>
<h3
id="jakie-warunki-musi-spełniać-model-programowy-procesora-aby-możliwa-była-realizacja-tego-procesora-w-postaci-struktury-jednocyklowej">54.
Jakie warunki musi spełniać model programowy procesora, aby możliwa była
realizacja tego procesora w postaci struktury jednocyklowej?</h3>
<ul>
<li>Model programowy klasy RISC</li>
<li>Architektura Harvard - stała pamięć programu typu ROM</li>
</ul>
<h3
id="jaką-operację-realizuje-jednostka-arytmetyczno-logiczna-podczas-wykonywania-instrukcji-ładowania-i-składowania-w-procesorze-jednocyklowym-i-w-prostych-procesorach-potokowych">55.
Jaką operację realizuje jednostka arytmetyczno-logiczna podczas
wykonywania instrukcji ładowania i składowania w procesorze
jednocyklowym i w prostych procesorach potokowych?</h3>
<p>Oblicza adres danej - suma zawartości rejestru bazowego i
przemieszczenia</p>
<h3
id="podać-przykład-sekwencji-instrukcji-generującej-hazard-typu-odczyt-po-zapisie-raw.">56.
Podać przykład sekwencji instrukcji generującej hazard typu odczyt po
zapisie (RAW).</h3>
<pre><code>add   t1, t2, t3
add   t4, t5, t1</code></pre>
<ul>
<li>Wynik pierwszej instrukcji jest argumentem do kolejnej</li>
<li>Druga instrukcja może pobrać zawartość t1 zanim pierwsza instrukcja
zapisze wynik swojej operacji</li>
</ul>
<h3
id="dlaczego-usuwanie-hazardu-raw-przy-użyciu-obejść-jest-efektywniejsze-niż-przy-użyciu-innych-mechanizmów">57.
Dlaczego usuwanie hazardu RAW przy użyciu obejść jest efektywniejsze,
niż przy użyciu innych mechanizmów?</h3>
<ul>
<li>Metoda administracyjna
<ul>
<li>Zakaz używania instrukcji powodujących hazard</li>
<li>Trzeba dodawać puste instrukcje <code>nop</code></li>
<li>Instrukcje <code>nop</code> zajmą większość programu</li>
</ul></li>
<li>Wykrywanie i poślizg
<ul>
<li>Układ wykrywa hazard porównując numery rejestrów w poszczególnych
stopniach potoku</li>
<li>Jeśli występuje hazard to stopnie IF i RD są zatrzymywane</li>
<li>Automatyczne wstrzykiwanie instrukcji <code>nop</code></li>
<li>Będzie bardzo dużo takich zatrzymań (jak przy metodzie
administracyjnej)</li>
</ul></li>
<li>Obejścia
<ul>
<li>Eliminuje hazard RAW bez wprowadzania żadnych opóźnień -
najlepsza</li>
<li>Dodatkowe szyny z wyjść ALU i MEM na wejście RD</li>
<li>Wszystkie wyniki które już istnieją ale nie są jeszcze zapisane do
rejestru/pamięci są dostępne do odczytu po szynie obejścia</li>
</ul></li>
</ul>
<h3
id="dlaczego-hazardu-raw-przy-ładowaniu-danej-z-pamięci-nie-można-usunąć-bez-wprowadzenia-opóźnienia">58.
Dlaczego hazardu RAW przy ładowaniu danej z pamięci nie można usunąć bez
wprowadzenia opóźnienia?</h3>
<pre><code>lw    t4, ...
add   t6, t5, t4</code></pre>
<ul>
<li>Load-use penalty</li>
<li>Dana jest dostępna w stopniu MEM a używana w stopniu RD</li>
<li>Kiedy instrukcja używająca jest w stopniu RD to ładująca jest
jeszcze w ALU - nie ma jeszcze danej</li>
<li>Nie da się wyeliminować opóźnienia ze względu na odstęp między
stopniami RD i MEM</li>
<li>Odstęp można zredukować przez obejścia</li>
</ul>
<h3
id="skąd-bierze-się-opóźnienie-skoków-w-architekturach-potokowych">59.
Skąd bierze się opóźnienie skoków w architekturach potokowych?</h3>
<ul>
<li>Opóźnienie skoku bierze się z odległości między stopniem IF i
ALU</li>
<li>Adres skoku jest wyliczany w stopniu ALU</li>
<li>W stopniu RD już przebywa instrukcja która była po skoku - marnuje
czas procesora</li>
</ul>
<h3 id="co-to-jest-skok-opóźniony">60. Co to jest skok opóźniony?</h3>
<ul>
<li>Delayed branch</li>
<li>Technika redukcji opóźnienia skoku używana w krótkich potokach</li>
<li>Skok opóźniony - Wykonaj instrukcję bezpośrednio za skokiem i
skocz</li>
<li>Slot opóźnienia - miejsce na instrukcję za skokiem
<ul>
<li>wypełniony użyteczną instrukcją jeśli warunek skoku od niej nie
zależy</li>
<li>wypełniony <code>nop</code> w przeciwnym wypadku</li>
</ul></li>
</ul>
<h3
id="dlaczego-skoków-opóźnionych-nie-stosuje-się-w-architekturach-o-długich-potokach">61.
Dlaczego skoków opóźnionych nie stosuje się w architekturach o długich
potokach?</h3>
<ul>
<li>Więcej stopni potoku -&gt; większa odległość między stopniem
pobrania instrukcji a wyliczeniem adresu -&gt; większe opóźnienie</li>
<li>Slot opóźnienia się wydłuża ale rzadko daje się wypełnić użytecznymi
instrukcjami</li>
<li>Przewidywanie skoków jest bardziej skuteczną metodą</li>
</ul>
<h3
id="wymienić-dwa-sposoby-potokowych-realizacji-modeli-programowych-cisc.">62.
Wymienić dwa sposoby potokowych realizacji modeli programowych
CISC.</h3>
<ul>
<li>Procesor z transkodowaniem instrukcji
<ul>
<li>Instrukcje CISC transkodowane na RISC</li>
<li>potok RISC</li>
</ul></li>
<li>Potok CISC</li>
</ul>
<h3
id="w-jakich-procesorach-występuje-transkoder-instrukcji-i-na-czym-polega-jego-działanie">63.
W jakich procesorach występuje transkoder instrukcji i na czym polega
jego działanie?</h3>
<ul>
<li>Występuje w realizacji procesorów CISC z transkodowaniem i jednostką
wykonawczą typu RISC</li>
<li>Transkoder pobiera instrukcje CISC i zamienia je na sekwencje
instrukcji RISC
<ul>
<li>1-1 dla prostych instrukcji</li>
<li>1-2..4 dla bardziej złożonych instrukcji</li>
<li>Bardzo złożone są trzymane jako procedury RISC i pobierane z pamięci
ROM</li>
</ul></li>
</ul>
<h3
id="kiedy-procesor-superskalarny-może-równocześnie-rozpocząć-wykonanie-dwóch-lub-większej-liczby-instrukcji">64.
Kiedy procesor superskalarny może równocześnie rozpocząć wykonanie dwóch
lub większej liczby instrukcji?</h3>
<p>Kiedy instrukcje nie zależą od wcześniejszych, które są kierowane do
potoku w tym samym cyklu</p>
<h3
id="w-jakich-architekturach-występują-hazardy-war-i-waw-w-jaki-sposób-można-je-usunąć">65.
W jakich architekturach występują hazardy WAR i WAW? W jaki sposób można
je usunąć?</h3>
<p>Występują w architekturach z superskalarnych (ze zmianą kolejności
instrukcji)</p>
<p>Hazardy są powodowane przez wielokrotne używanie tych samych
zmiennych (rejestrów procesora) do przechowywania różnych wartości</p>
<p>Hazardy rozwiązuje się przez dodanie większej liczby rejestrów,
niewidocznych w modelu programowym i dynamiczne przypisywanie tych
fizycznych rejestrów do rejestrów modelu programowego - register
renaming</p>
<h3
id="dlaczego-opóźnienie-skoków-i-opóźnienie-ładowania-danych-mają-duży-wpływ-na-wydajność-współczesnych-procesorów">66.
Dlaczego opóźnienie skoków i opóźnienie ładowania danych mają duży wpływ
na wydajność współczesnych procesorów?</h3>
<p>Współczesne procesory stosuję architekturę wielopotokową, opóźnienia
związane ze skokami lub ładowaniem danych, które wstrzymują potoki
powodują utratę cykli w każdym potoku względem idealnej wydajności.</p>
<p>W superskalarach opóźnienie jest o tyle gorsze że liczbe straconych
cykli mnoży się przez liczbę potoków</p>
<h3
id="na-czym-polega-fuzja-instrukcji-spotykana-we-współczesnych-procesorach-x86-podać-przykład-instrukcji-które-mogą-podlegać-fuzji">67.
Na czym polega fuzja instrukcji spotykana we współczesnych procesorach
x86? Podać przykład instrukcji, które mogą podlegać fuzji</h3>
<ul>
<li>Fuzja polega na łączeniu dwóch instrukcji programu w jedną wewnątrz
procesora</li>
<li>Często występujące pary (<code>cmp</code>, <code>jcc</code>)
instrukcji CISC zamieniane na jedną instrukcję RISC</li>
</ul>
<h2 id="kieszenie">Kieszenie</h2>
<h3 id="co-to-jest-linia-kieszeni">68. Co to jest linia kieszeni?</h3>
<p>Pojedynczy element przechowywany w kieszeni, blok danych (dłuższy od
słowa pamięci) + znaczniki (w tym adres)</p>
<h3 id="opisać-optymalny-algorytm-wyznaczania-ofiar-w-kieszeni.">69.
Opisać optymalny algorytm wyznaczania ofiar w kieszeni.</h3>
<p>Należy wymienić tą linię, która najdłużej nie będzie używana w
przyszłości (nie da się zrealizować bo nie wiadomo co będzie będzie
potrzebne w przyszłości).</p>
<p>Heurystyka LRU - należy wyrzucić tą linię która najdłużej nie była
używana (nie jest faktycznie optymalny ale jest najlepszy możliwy do
zrealizowania)</p>
<h3
id="podać-przykłady-fragmentów-programów-przy-wykonaniu-których-zastosowanie-kieszeni-asocjacyjnej-z-algorytmem-lru-do-wyznaczania-ofiar-daje-wyniki-znaczne-gorszelepsze-niż-zastosowanie-kieszeni-bezpośrednio-adresowanej.">70.
Podać przykłady fragmentów programów, przy wykonaniu których
zastosowanie kieszeni asocjacyjnej z algorytmem LRU do wyznaczania ofiar
daje wyniki znaczne gorsze/lepsze niż zastosowanie kieszeni bezpośrednio
adresowanej.</h3>
<ul>
<li>Najgorszy przypadek
<ul>
<li>zbiór roboczy większy od pojemności kieszeni</li>
<li>100% chybień</li>
<li>W pierwszej iteracji pętli zapełni się n komórek kieszeni</li>
<li>Zapisanie w kieszeni n+1 komórki wymaga wyrzucenia pierwszej
itd.</li>
<li>Przy kolejnej iteracji pętli każdą instrukcję po kolei trzeba pobrać
z pamięci</li>
</ul></li>
<li>Idealny przypadek
<ul>
<li>zbiór roboczy mniejszy lub równy pojemności kieszeni</li>
<li>100% trafień</li>
<li>kieszeń wypełni się w pierwszej iteracji pętli i każda kolejna
będzie tylko czytać z kieszeni</li>
</ul></li>
</ul>
<h3
id="określić-które-bity-adresu-służą-do-adresowania-danych-wewnątrz-linii-które-do-wyboru-zbioru-a-które-są-używane-w-znacznikach-adresów-znając-całkowitą-pojemność-kieszeni-jej-asocjacyjność-i-długość-linii.-przyjmujemy-że-przy-dostępie-do-kieszeni-używa-się-adresów-wirtualnych.">71.
Określić, które bity adresu służą do adresowania danych wewnątrz linii,
które do wyboru zbioru, a które są używane w znacznikach adresów znając
całkowitą pojemność kieszeni, jej asocjacyjność i długość linii.
(Przyjmujemy, że przy dostępie do kieszeni używa się adresów
wirtualnych.)</h3>
<ul>
<li>24 KiB, 6, 32 B
<ul>
<li>najmniej znaczące 5b na wybór bajtu z linii (1 z 32)</li>
<li>jest 24KiB / (6 * 32B) = 128 zbiorów -&gt; 7 bajtów na wybranie
zbioru</li>
<li>najbardziej znaczące (n-12)b w znaczniku</li>
</ul></li>
<li>32 KiB, 8, 64 B
<ul>
<li>6b na wybór bajtu z linii</li>
<li>6b na wybór 1 z 64 = 32KiB/(8*64B) zbiorów</li>
<li>(n-12)b w znaczniku</li>
</ul></li>
<li>16 KiB, 2, 32 B
<ul>
<li>5b na wybór 1 z 32 bajtów w linii</li>
<li>8b na wybór 1 z 256 = 16KiB/(2*32B) zbiorów</li>
<li>(n-13)b w znaczniku</li>
</ul></li>
<li>128 KiB, 8, 64 B
<ul>
<li>6b na wybór 1 z 64 bajtów w linii</li>
<li>8b na wybór 1 z 256 = 128KiB/(8*64B) zbiorów</li>
<li>(n-14)b w znaczniku</li>
</ul></li>
</ul>
<h3 id="od-czego-zależy-współczynnik-trafień-kieszeni">72. Od czego
zależy współczynnik trafień kieszeni?</h3>
<ul>
<li>Pojemności kieszeni</li>
<li>Organizacji i algorytmu wymiany</li>
<li>Wykonywanego programu</li>
</ul>
<h3
id="podać-wzór-na-średni-czas-dostępu-hierarchii-pamięci-złożonej-z-dwóch-poziomów-kieszeni-i-pamięci-operacyjnej.">73.
Podać wzór na średni czas dostępu hierarchii pamięci złożonej z dwóch
poziomów kieszeni i pamięci operacyjnej.</h3>
<p>Dostęp do danego stopnia = średni czas dostępu do tego stopnia +
średni czas dostępu do reszty hierarchii pamięci t_avg_n = h_n * t_n +
(1-h_n) * t_avg_n+1</p>
<p>t_avg_l1 = h_l1 * t_l1 + (1-h_l1) * t_avg_l2 t_avg_l2 = h_l2 * t_l2 +
(1-h_l2) * t_mem</p>
<h3
id="obliczyć-średni-czas-dostępu-do-hierarchii-pamięci-o-podanych-parametrach-czasy-dostępu-współczynniki-trafień-kieszeni.">74.
Obliczyć średni czas dostępu do hierarchii pamięci o podanych
parametrach (czasy dostępu, współczynniki trafień kieszeni).</h3>
<ul>
<li>Czas dostępu L1 -&gt; 1 cykl</li>
<li>Czas dostępu L2 -&gt; 5 cykli</li>
<li>Czas dostępu pamięci -&gt; 100 cykli</li>
<li>Współczynnik trafień L1 -&gt; 0.96</li>
<li>Współczynnik trafień L2 -&gt; 0.99</li>
</ul>
<p>Średni czas dostępu do hierarchii 1 * 0.96 + (1-0.96) * (5 * 0.99 +
(1-0.99) * 100) = 1.198</p>
<h3
id="jakie-przesłania-danych-mają-miejsce-w-przypadku-chybienia-odczytu-kieszeni-l1-powodującego-chybienietrafienie-w-kieszeni-l2-jeśli-kieszenie-te-współpracują-na-zasadzie-inkluzywnejwyłącznej">75.
Jakie przesłania danych mają miejsce w przypadku chybienia odczytu
kieszeni L1 powodującego chybienie/trafienie w kieszeni L2, jeśli
kieszenie te współpracują na zasadzie inkluzywnej/wyłącznej?</h3>
<h4 id="kieszeń-inkluzywna">Kieszeń inkluzywna</h4>
<ul>
<li>Trafienie L2
<ul>
<li>L2 do L1</li>
<li>L1 do procesora</li>
<li>usunięcie ofiary z L1</li>
</ul></li>
<li>Chybienie L2
<ul>
<li>pamięć do L2</li>
<li>L2 do L1</li>
<li>L1 do procesora</li>
<li>usunięcie ofiary z L2 i tej samej linii z L1</li>
</ul></li>
</ul>
<h4 id="kieszeń-wyłączna">Kieszeń wyłączna</h4>
<ul>
<li>Trafienie L2
<ul>
<li>Wymiana linii między L1 i L2</li>
</ul></li>
<li>Chybienie L2
<ul>
<li>Ofiara z L1 do L2</li>
<li>Ofiara z L2 do pamięci</li>
<li>Linia z pamięci do L1</li>
</ul></li>
</ul>
<h3
id="podać-przykład-sytuacji-operacji-wykonywanych-w-programie-gdy-kieszeń-z-alokacją-linii-przy-chybieniu-zapisu-wbwa-będzie-działać-wolniej-niż-kieszeń-bez-alokacji-wbnwa.">76.
Podać przykład sytuacji (operacji wykonywanych w programie), gdy kieszeń
z alokacją linii przy chybieniu zapisu (WB/WA) będzie działać wolniej,
niż kieszeń bez alokacji (WB/NWA).</h3>
<p>???</p>
<h3
id="kiedy-może-wystąpić-niespójność-zawartości-kieszeni-i-pamięci-operacyjnej">77.
Kiedy może wystąpić niespójność zawartości kieszeni i pamięci
operacyjnej?</h3>
<p>Problem może wystąpić kiedy jest więcej niż 1 ścieżka dostępu do
hierarchii pamięci</p>
<ul>
<li>Oddzielne kieszenie L1 do kodu i danych</li>
<li>Dwa procesory z oddzielnymi kieszeniami L1 i wspólną resztą
hierarchii</li>
<li>Procesor z kieszenią i sterownik IO odwołujący się bezpośrednio do
pamięci</li>
</ul>
<h2 id="zarządzanie-zasobami">Zarządzanie zasobami</h2>
<h3 id="na-czym-polega-ochrona-procesora">78. Na czym polega ochrona
procesora?</h3>
<ul>
<li>Na zapewnieniu, że żaden proces nie może zmonopolizować czasu
procesora (system operacyjny przełącza procesy)</li>
<li>Ograniczenie dostępu do specjalnych zasobów (np systemowy rejestr
stanu dostępny tylko na poziomie uprzywilejowania systemu)</li>
<li>Timer systemowy zgłasza wyjątek co określony czas, system operacyjny
przejmuje kontrolę</li>
</ul>
<h3 id="wymienić-funkcje-zadania-systemu-zarządzania-pamięcią.">79.
Wymienić funkcje (zadania) systemu zarządzania pamięcią.</h3>
<ul>
<li>Sprzętowa relokacja - kilka zadań może wykonywać się jednocześnie i
używać tych samych wartości adresów, które będą mapowane do innych
fizycznych komórek pamięci w sposób niewidoczny dla zadania</li>
<li>Ochrona
<ul>
<li>zabezpieczenie przed dostępem poza sekcje pamięci przydzielone do
procesu</li>
<li>zabezpieczenie przed niewłaściwym dostępem do własnych sekcji
pamięci procesu
<ul>
<li>zapis do sekcji stałych</li>
<li>zapis do sekcji kodu</li>
<li>wykonywanie instrukcji z sekcji danych</li>
</ul></li>
</ul></li>
<li>Dynamiczna alokacja i dealokacja - powiększanie i zmniejszanie
rozmiaru przestrzeni adresowej dostępnej dla procesu w trakcie jego
pracy</li>
<li>Wirtualizacja - uniezalenienie rozmiaru pamięci dostępnej dla
zadania od faktycznie dostępnej pamięci operacyjnej (wielkość
zamontowana w komputerze i stopień wykorzystania przez inne
zadania)</li>
</ul>
<h3 id="na-czym-polega-i-do-czego-służy-sprzętowa-relokacja-adresów">80.
Na czym polega i do czego służy sprzętowa relokacja adresów?</h3>
<ul>
<li>Relokacja służy temu, żeby wiele zadań (np. o dokładnie tym samym
kodzie i zahardkodowanych adresach) mogły poprawnie wykonywać się
jednocześnie</li>
<li>Polega na mapowaniu wirtualnych adresów używanych w programie przez
jednostkę relokacji na fizyczne adresy komórek pamięci</li>
</ul>
<h3
id="dlaczego-adresy-logiczne-o-wartościach-bliskich-0-nie-są-na-ogół-dostępne-dla-programów-użytkowych-we-współczesnych-systemach-operacyjnych">81.
Dlaczego adresy logiczne o wartościach bliskich 0 nie są na ogół
dostępne dla programów użytkowych we współczesnych systemach
operacyjnych?</h3>
<p>(???) To gwarantuje że odwołanie do pamięci przez
<code>nullptr</code> od razu spowoduje błąd</p>
<h3 id="jakie-informacje-zawiera-deskryptor-segmentustrony">82. Jakie
informacje zawiera deskryptor segmentu/strony?</h3>
<h4 id="deskryptor-strony">Deskryptor strony</h4>
<ul>
<li>znacznik ważności</li>
<li>znaczniki praw dostępu do strony</li>
<li>fizyczny numer strony</li>
<li>dodatkowe atrybuty wykorzystywane przez system operacyjny
<ul>
<li>no-execute</li>
<li>…</li>
</ul></li>
</ul>
<h4 id="deskryptor-segmentu">Deskryptor segmentu</h4>
<ul>
<li>adres bazowy segmentu</li>
<li>rozmiar segmentu</li>
<li>znacnzik ważności deskryptora</li>
<li>prawa dostępu do segmentu</li>
<li>dodatkowe pola
<ul>
<li>bity do wykorzystania przez oprogramowanie</li>
<li>dodatkowe znaczniki …</li>
</ul></li>
</ul>
<h3 id="w-jaki-sposób-jednostka-segmentacji-generuje-adres-liniowy">83.
W jaki sposób jednostka segmentacji generuje adres liniowy?</h3>
<ul>
<li>Sumuje liniowy adres bazowy segmentu i adres wewnątrzsegmentowy
(offset)</li>
<li>Jeśli nie zgadzają się prawa dostępu / zakres adresu to zgłasza
wyjątek</li>
</ul>
<h3
id="co-oznaczają-bity-dostępu-i-modyfikacji-w-deskryptorze-strony-kiedy-i-przez-co-są-one-zerowane-i-ustawiane-w-stan-1">84.
Co oznaczają bity dostępu i modyfikacji w deskryptorze strony? Kiedy i
przez co są one zerowane i ustawiane w stan 1?</h3>
<ul>
<li>bit dostępu - czy był odczyt ze strony</li>
<li>bit modyfikacji - czy był zapis do strony</li>
<li>ustawiane przez przez system operacyjny</li>
<li>wykorzystywane przy mechanizmie zapisu typu write-back - strona jest
zapisywana na dysk tylko jeśli naprawdę trzeba</li>
</ul>
<h3
id="w-jakich-sytuacjach-jednostka-segmentacjistronicowania-zgłasza-błąd-segmentustrony">85.
W jakich sytuacjach jednostka segmentacji/stronicowania zgłasza błąd
segmentu/strony?</h3>
<ul>
<li>nieważny deskryptor</li>
<li>tryb dostępu niezgodny z uprawnieniami określonymi w
deskryptorze</li>
<li>(jednostka segmentacji) adres wewnątrzsegmentowy przekracza rozmiar
segmentu</li>
</ul>
<h3
id="dlaczego-do-przechowywania-deskryptorów-stron-używa-się-struktur-tablicowo-drzewiastych-a-nie-zwykłych-wektorów">86.
Dlaczego do przechowywania deskryptorów stron używa się struktur
tablicowo-drzewiastych, a nie zwykłych wektorów?</h3>
<ul>
<li>Zastosowanie struktury tablicowo-drzewiastej eliminuje konieczność
przechowywania przez każdy proces deskryptorów dla całej przestrzeni
adresowej (4MiB w trybie 32-bitowym)</li>
<li>Proces najczęściej wykorzystuje tlyko małą część przestrzeni
adresowej</li>
<li>Mniejsza tablica 2 poziomu przechowuje wskaźniki do tablic
wykorzystywanych deskryptorów stron albo puste wskaźniki</li>
<li>Zmniejsza się narzut zajętej pamięci przez proces związany ze
stronicowaniem</li>
</ul>
<h3 id="co-to-jest-table-walk">87. Co to jest „table walk”?</h3>
<p>Przeglądanie drzewiasto-tablicowej struktury deskryptorów stron z
pamięci, konieczne po chybieniu bufora translacji</p>
<h3
id="skąd-bierze-się-wysoki-koszt-czasowy-chybień-bufora-translacji">88.
Skąd bierze się wysoki koszt czasowy chybień bufora translacji?</h3>
<p>Chybienie bufora translacji wymaga wykonania kilku dostępów do
pamięci, we współczesnych procesorach superskalarnych koszt czasowy
odwołania do pamięci jest rzędu wykonania kilkuset instrukcji</p>
<h3
id="jakie-deskryptory-stron-są-oznaczone-jako-globalne-i-jakie-znaczenie-ma-ten-atrybut-deskryptora">89.
Jakie deskryptory stron są oznaczone jako globalne i jakie znaczenie ma
ten atrybut deskryptora?</h3>
<ul>
<li>Deskryptory stron systemowych (ważnych dla wszystkich procesów) są
oznaczane jako globalne</li>
<li>Deskryptory z ustawionym znacznikiem nie są usuwane z bufora
translacji przy przełączaniu procesów - oszczędność czasu</li>
</ul>
<h3 id="jakie-pola-zawiera-nieważny-deskryptor-strony">90. Jakie pola
zawiera nieważny deskryptor strony?</h3>
<ul>
<li>znacznik ważności ustawiony na 0</li>
</ul>
<h3
id="dlaczego-rozróżnienie-prawa-dostępu-do-odczytu-danych-i-do-pobrania-instrukcji-wjednostce-zarządzania-pamięcią-podnosi-bezpieczeństwo-systemu">91.
Dlaczego rozróżnienie prawa dostępu do odczytu danych i do pobrania
instrukcji wjednostce zarządzania pamięcią podnosi bezpieczeństwo
systemu?</h3>
<p>Uniemożliwienie pobrania danych i wykonania ich jako instrukcji
zabezpiecza przed atakiem typu buffer overflow z wykonaniem
wstrzykniętego kodu</p>
<h3
id="jednostka-stronicowania-procesora-przechowuje-deskryptory-stron-w-strukturze-tablicowo-drzewiastej-w-której-tablice-mają-rozmiar-strony.-podstawowy-rozmiar-strony-jest-równy-p-a-rozmiar-deskryptora-d.-określić-kolejno-następujące-parametry-jednostki-stronicowania-translującej-adres-wirtualny-nie-krótszy-niż-a-bitów--minimalną-liczbę-poziomów-struktury-tablicowo-drzewiastej--maksymalną-długość-adresu-wirtualnego-przy-tej-liczbie-poziomów--budowę-adresu-wirtualnego-jego-podział-na-indeksy-tablic-i-adres-wewnątrztrzstronicowy--możliwe-rozmiary-dużych-stron.przykładowe-dane-a-p-8-kib-d-8-b-a-40-b-p-16-kib-d-8-b-a-48-c-p-8-kib-d-4-b-a-32.">92.
Jednostka stronicowania procesora przechowuje deskryptory stron w
strukturze tablicowo-drzewiastej, w której tablice mają rozmiar strony.
Podstawowy rozmiar strony jest równy p, a rozmiar deskryptora –
d. Określić kolejno następujące parametry jednostki stronicowania,
translującej adres wirtualny nie krótszy niż a bitów:- minimalną liczbę
poziomów struktury tablicowo-drzewiastej,- maksymalną długość adresu
wirtualnego przy tej liczbie poziomów,- budowę adresu wirtualnego – jego
podział na indeksy tablic i adres wewnątrztrzstronicowy,- możliwe
rozmiary „dużych” stron.Przykładowe dane: a) p = 8 KiB, d = 8 B, a = 40;
b) p = 16 KiB, d = 8 B, a = 48; c) p = 8 KiB, d = 4 B, a = 32.</h3>
<h3
id="przyjmując-parametry-jednostki-stronicowania-z-poprzedniego-zadania-oszacować-całkowity-rozmiar-prywatnych-tablic-deskryptorów-stron-najmniejszego-procesu-użytkowego-korzystającego-ze-sterty-przy-założeniu-że-każda-z-czterech-sekcji-pamięci-procesu-jest-opisana-oddzielną-tablicą-stron-o-rozmiarze-podstawowym.">93.
Przyjmując parametry jednostki stronicowania z poprzedniego zadania,
oszacować całkowity rozmiar prywatnych tablic deskryptorów stron
najmniejszego procesu użytkowego korzystającego ze sterty, przy
założeniu, że każda z czterech sekcji pamięci procesu jest opisana
oddzielną tablicą stron o rozmiarze podstawowym.</h3>
<h2 id="wyjątki">Wyjątki</h2>
<h3 id="co-to-jest-wyjątek">94. Co to jest wyjątek?</h3>
<p>Zdarzenie w systemie komputerowym wymagające przerwania wykonania
bieżącego strumienia instrukcji i przekazania sterowania do systemu
operacyjnego</p>
<h3
id="wymienić-i-scharakteryzować-poszczególne-klasy-wyjątków-podać-po-kilka-przykładów-wyjątków-poszczególnych-klas.">95.
Wymienić i scharakteryzować poszczególne klasy wyjątków, podać po kilka
przykładów wyjątków poszczególnych klas.</h3>
<ul>
<li>Asynchroniczne - nie wynikają z wykonywanych instrukcji lub
niemożliwe do powiązania z konkretną instrukcją
<ul>
<li>przerwania
<ul>
<li>timer systemowy</li>
<li>przesunięcie myszy</li>
<li>wciśnięcie klawisza na klawiaturze</li>
<li>nadejście pakietu z sieci lokalnej</li>
</ul></li>
<li>błędy krytyczne</li>
</ul></li>
<li>Synchroniczne - wynikające z wykonania instrukcje, obsługiwane
natychmiast po wygenerowaniu
<ul>
<li>pułapki
<ul>
<li>wywołania systemowe</li>
<li>nadmiary operacji arytmetycznych</li>
<li>tryb śledzenia (do debuggowania)</li>
</ul></li>
<li>błędy
<ul>
<li>naprawialne</li>
<li>nienaprawialne</li>
<li>naruszenie zasad ochrony procesora / pamięci</li>
<li>błąd wyrównania danych</li>
<li>próba wykonania niezdefiniowanej instrukcji</li>
</ul></li>
</ul></li>
</ul>
<h3 id="czym-różni-się-obsługa-przerwań-od-obsługi-innych-wyjątków">96.
Czym różni się obsługa przerwań od obsługi innych wyjątków?</h3>
<p>Obsługa przerwania może być odsunięta w czasie</p>
<h3
id="co-wskazuje-wartość-licznika-instrukcji-zapamiętywana-podczas-obsługi-wyjątków-poszczególnych-typów">97.
Co wskazuje wartość licznika instrukcji zapamiętywana podczas obsługi
wyjątków poszczególnych typów?</h3>
<ul>
<li>nextPC
<ul>
<li>przerwania</li>
<li>pułapki wywołania systemu i śledzenia</li>
</ul></li>
<li>currentPC
<ul>
<li>pułapki sygnalizujące błąd wykonania (do identyfikacja miejsca
błędu)</li>
<li>błędy (nie udało się wykonać instrukcji, nextPC jest niedostępny lub
nieważny)</li>
</ul></li>
</ul>
<h3
id="dlaczego-do-wywoływania-usług-systemowych-przez-program-użytkowy-nie-można-użyć-instrukcji-skoku-ze-śladem">98.
Dlaczego do wywoływania usług systemowych przez program użytkowy nie
można użyć instrukcji skoku ze śladem?</h3>
<h3
id="czym-różni-się-instrukcja-powrotu-z-obsługi-wyjątku-od-instrukcji-powrotu-ze-zwykłej-procedury.">99.
Czym różni się instrukcja powrotu z obsługi wyjątku od instrukcji
powrotu ze zwykłej procedury.</h3>
<p>Przy powrocie z obsługi wyjątku trzeba przywrócić rejestr stanu
procesora (dostępne tylko na poziomie uprzywilejowania systemu)</p>
<h3
id="w-jaki-sposób-zmienia-się-priorytet-procesora-podczas-obsługi-przerwania">100.
W jaki sposób zmienia się priorytet procesora podczas obsługi
przerwania?</h3>
<p>Procesor przyjmuje priorytet obsługiwanego przerwania</p>
<h3
id="jaka-relacja-musi-zachodzić-pomiędzy-priorytetem-przerwania-i-priorytetem-procesora-aby-przerwanie-mogło-zostać-obsłużone">101.
Jaka relacja musi zachodzić pomiędzy priorytetem przerwania i
priorytetem procesora, aby przerwanie mogło zostać obsłużone?</h3>
<p>Priorytet przerwania musi być wyższy od aktualnego priorytetu
procesora</p>
<h3 id="co-to-jest-późne-przybycie-przerwania">102. Co to jest „późne
przybycie” przerwania?</h3>
<ul>
<li>Opóźnienie obsługi przerwania o wyższym priorytecie zgłoszonym
podczas obsługi przerwania o niższym priorytecie</li>
<li>Opóźnienie wynika z podwójnego składowania kontekstu na stosie
systemowym</li>
</ul>
<h3
id="na-czym-polega-łańcuchowanie-przerwań-zrealizowane-w-architekturze-armv6v7">103.
Na czym polega łańcuchowanie przerwań, zrealizowane w architekturze
ARMv6/v7?</h3>
<ul>
<li>Dotyczy sytuacji kiedy podczas obsługi przerwania zostaje zgłoszony
przerwanie o mniejszym lub równym priorytecie</li>
<li>Przy powrocie z obsługi aktualnego przerwania, jeśli odtwarzany
kontekst ma niższy priorytet niż oczekujące przerwanie, to nie odtwarza
się tego kontekstu (mniejsze opóźnienie) i przechodzi od razu do obsługi
oczekującego przerwania</li>
<li>Nie wykonują się żadne instrukcje kodu o niższym priorytecie</li>
</ul>
<h3
id="wyjaśnić-różnicę-pomiędzy-poziomem-zaufania-i-priorytetem-procesora.">104.
Wyjaśnić różnicę pomiędzy poziomem zaufania i priorytetem
procesora.</h3>
<h3
id="jakie-informacje-są-zapamiętywane-przez-procesor-podczas-obsługi-błędu-strony">105.
Jakie informacje są zapamiętywane przez procesor podczas obsługi błędu
strony?</h3>
<h3
id="na-czym-polega-restart-instrukcji-stosowany-przy-obsłudze-błędów">106.
Na czym polega restart instrukcji, stosowany przy obsłudze błędów?</h3>
<p>Przywrócenie stanu procesora sprzed wykonania instrukcji, która
wygenerowała błąd po powrocie z procedury obsługi błędu</p>
<h3
id="dlaczego-we-współczesnych-architekturach-przy-obsłudze-błędów-przez-procesor-używa-się-metody-restartu-instrukcji-a-nie-kontynuacji">107.
Dlaczego we współczesnych architekturach przy obsłudze błędów przez
procesor używa się metody restartu instrukcji, a nie kontynuacji?</h3>
<p>Jest łatwiejsze przy spekulatywnym wykonywaniu instrukcji, nie wymaga
odtwarzania kontekstu mikrokodu procesora w środku instrukcji</p>
<h3
id="jaki-jest-skutek-wykonania-przez-program-użytkowy-instrukcji-powrotu-z-obsługi-wyjątku">108.
Jaki jest skutek wykonania przez program użytkowy instrukcji powrotu z
obsługi wyjątku?</h3>
<p>Przeładowanie zawartości rejestru stanu - możliwe tylko w trybie
systemowym bo pozwala na zmianę poziomu uprzywilejowania</p>
<h3 id="co-to-jest-błąd-podwójny">109. Co to jest błąd podwójny?</h3>
<ul>
<li>Błąd pojawiający się podczas obsługi innego błędu (np. związany z
zarządzaniem pamięcią)</li>
<li>Nie ma ważnej wartości PC</li>
<li>Jest błędem w systemie operacyjnym</li>
</ul>
<h3 id="co-to-jest-przechwycenie">110. Co to jest przechwycenie?</h3>
<h3
id="wyjaśnić-zasadę-ataku-typu-buffer-overflow-i-rolę-atrybutu-strony-executable-w-zapobieganiu-tego-typu-atakom.">111.
Wyjaśnić zasadę ataku typu buffer overflow i rolę atrybutu strony
executable w zapobieganiu tego typu atakom.</h3>
<ul>
<li>Buffer overflow polega na wstrzyknięciu przez użytkownika kodu do
pamięci (przy niebezpiecznym czytaniu stringa w C, bez sprawdzenia
zakresu) i wykonaniu tego kodu</li>
<li>Znacznik executable zabezpiecza przed tym atakiem w ten sposób, że
nie zezwala na wykonywanie strony oznaczonej jako dane, tak jakby były
instrukcjami</li>
</ul>
<h2 id="pamięć-wirtualna">Pamięć wirtualna</h2>
<h3
id="jakie-mechanizmy-musi-udostępniać-procesor-aby-mógł-on-pracować-w-systemie-pamięci-wirtualnej">112.
Jakie mechanizmy musi udostępniać procesor, aby mógł on pracować w
systemie pamięci wirtualnej?</h3>
<h3
id="opisać-rolę-poszczególnych-składników-sprzętowych-i-programowych-w-implementacji-pamięci-wirtualnej.">113.
Opisać rolę poszczególnych składników sprzętowych i programowych w
implementacji pamięci wirtualnej.</h3>
<h3
id="kiedy-strona-zaalokowana-dla-procesu-przez-system-operacyjny-może-mieć-nieważny-deskryptor">114.
Kiedy strona zaalokowana dla procesu przez system operacyjny może mieć
nieważny deskryptor?</h3>
<h3 id="na-czym-polega-leniwa-alokacja-pamięci">115. Na czym polega
„leniwa” alokacja pamięci?</h3>
<h3 id="co-to-jest-aliasowanie-deskryptorów">116. Co to jest aliasowanie
deskryptorów?</h3>
<h2 id="wejście-wyjście">Wejście-wyjście</h2>
<h3
id="dlaczego-we-współczesnych-komputerach-uniwersalnych-w-zasadzie-nie-stosuje-się-obsługi-urządzeń-wejścia-wyjścia-przy-użyciu-aktywnego-oczekiwania">117.
Dlaczego we współczesnych komputerach uniwersalnych w zasadzie nie
stosuje się obsługi urządzeń wejścia-wyjścia przy użyciu aktywnego
oczekiwania?</h3>
<p>Aktywne oczekiwanie marnuje czas procesora czekając w pętli na
gotowość urządzenia, kiedy zamiast tego, mógłby przełączyć się na
wykonywanie innego zadania</p>
<h3
id="jakie-urządzenia-wejścia-wyjścia-wymagają-obsługi-przy-użyciu-bezpośredniego-dostępu-do-pamięci-scharakteryzować-cechy-takich-urządzeń">118.
Jakie urządzenia wejścia-wyjścia wymagają obsługi przy użyciu
bezpośredniego dostępu do pamięci (scharakteryzować cechy takich
urządzeń)?</h3>
<ul>
<li>Szybkie urządzenia (dsykim sterowniki sieciowe, dźwiękowe,
graficzne, USB)</li>
<li>Obsługa z użyciem przerwań wymagałaby zbyt dużego narzutu związanego
z obsługą przerwania przy każdej transmisji (a nie raz na blok jak w
DMA)</li>
</ul>
<h3
id="wymienić-rejestry-kanału-bezpośredniego-dostępu-do-pamięci-i-opisać-sposób-ich-zaprogramowania-przez-system-operacyjny-oraz-modyfikacji-przez-sprzęt-podczas-transmisji.">119.
Wymienić rejestry kanału bezpośredniego dostępu do pamięci i opisać
sposób ich zaprogramowania przez system operacyjny oraz modyfikacji
przez sprzęt podczas transmisji.</h3>
<ul>
<li>Rejestr adresu bufora danych w pamięci
<ul>
<li>przed transmisją bloku danych ładowany adresem początkowym
bufora</li>
<li>inkrementowany po każdym przesłaniu</li>
</ul></li>
<li>Licznik transmitowanych danych
<ul>
<li>ładowany długością bloku</li>
<li>dekrementowany po każdym przesłaniu</li>
</ul></li>
</ul>
<h3
id="wyjaśnić-z-czego-wynikają-ograniczenia-żywotności-popularnych-urządzeń-pamięci-masowej-stałych-dysków-magnetycznych-i-urządzeń-półprzewodnikowych-ssd-karty-pamięci">120.
Wyjaśnić z czego wynikają ograniczenia żywotności popularnych urządzeń
pamięci masowej – stałych dysków magnetycznych i urządzeń
półprzewodnikowych (SSD, karty pamięci)</h3>
<ul>
<li>Dyski magnetyczny - zużycie mechaniczne ruchomych talerzy i
głowic</li>
<li>Półprzewodnikowe</li>
</ul>

        </main>
    </div>
    <div class="table-of-contents">
        <nav id="TOC" role="doc-toc">
<ul>
<li><a href="#zadania-arko">Zadania ARKO</a>
<ul>
<li><a href="#wprowadzenie">Wprowadzenie</a>
<ul>
<li><a href="#co-to-jest-bajt">1. Co to jest bajt</a></li>
<li><a href="#dlaczego-do-wyrażania-pojemności-pamięci-operacyjnej-powinno-się-używać-krotności-binarnych-a-nie-dziesiętnych">2.
Dlaczego do wyrażania pojemności pamięci operacyjnej powinno się używać
krotności binarnych, a nie dziesiętnych?</a></li>
<li><a href="#dlaczego-zasoby-pamięciowe-współczesnych-komputerów-mają-budowę-hierarchiczną">3.
Dlaczego zasoby pamięciowe współczesnych komputerów mają budowę
hierarchiczną?</a></li>
<li><a href="#jaka-jest-ogólna-zasada-przemieszczania-obiektów-pomiędzy-warstwami-hierarchii-pamięci">4.
Jaka jest ogólna zasada przemieszczania obiektów pomiędzy warstwami
hierarchii pamięci?</a></li>
<li><a href="#jakie-mechanizmy-decydują-o-przemieszczaniu-obiektów-na-stykach-poszczególnych-warstw-hierarchii-pamięci">5.
Jakie mechanizmy decydują o przemieszczaniu obiektów na stykach
poszczególnych warstw hierarchii pamięci?</a></li>
<li><a href="#które-dwie-warstwy-hierarchii-pamięci-są-realizowane-przy-użyciu-tej-samej-struktury-i-tego-samego-fizycznego-urządzenia-jakie-jest-to-urządzenie">6.
Które dwie warstwy hierarchii pamięci są realizowane przy użyciu tej
samej struktury i tego samego fizycznego urządzenia? Jakie jest to
urządzenie?</a></li>
<li><a href="#czym-w-taksonomii-skillicorna-różni-się-połączenie-procesora-instrukcji-z-hierarchią-pamięci-instrukcji-od-połączenia-procesora-danych-z-hierarchią-pamięci-danych">7.
Czym w taksonomii Skillicorna różni się połączenie procesora instrukcji
z hierarchią pamięci instrukcji od połączenia procesora danych z
hierarchią pamięci danych?</a></li>
<li><a href="#czym-różni-się-silne-od-słabego-sprzężenia-procesorów-w-taksonomii-skillicorna">8.
Czym różni się „silne” od „słabego” sprzężenia procesorów w taksonomii
Skillicorna?</a></li>
<li><a href="#dlaczego-w-architekturze-harvard-nie-można-wprowadzić-nowego-programu-w-czasie-pracy-komputera">9.
Dlaczego w architekturze Harvard nie można wprowadzić nowego programu w
czasie pracy komputera?</a></li>
<li><a href="#na-czym-polega-wąskie-gardło-w-architekturze-princeton">10. Na
czym polega „wąskie gardło” w architekturze Princeton?</a></li>
<li><a href="#dlaczego-w-architekturze-harvard-princeton-nie-jest-możliwa-automodyfikacja-programu">11.
Dlaczego w architekturze Harvard-Princeton nie jest możliwa
automodyfikacja programu?</a></li>
</ul></li>
<li><a href="#reprezentacje-danych">Reprezentacje danych</a>
<ul>
<li><a href="#jaką-wagę-ma-najbardziej-znaczący-bit-16-bitowej-liczby-zapisanej-w-kodzie-u2">12.
Jaką wagę ma najbardziej znaczący bit 16-bitowej liczby zapisanej w
kodzie U2?</a></li>
<li><a href="#podać-postaci-binarne-słów-8-bitowych-reprezentujących-liczby-całkowite--120--64--21--10--5-i--1-w-kodach-u2-znak-moduł-i-spolaryzowanym-o-wartości-podkładu-127.">13.
Podać postaci binarne słów 8-bitowych reprezentujących liczby całkowite
-120, -64, -21, -10, -5 i -1 w kodach U2, znak-moduł i spolaryzowanym o
wartości podkładu 127.</a></li>
<li><a href="#dlaczego-w-zapisie-liczb-zmiennopozycyjnych-ieee754-nie-ma-potrzeby-przechowywania-części-całkowitej-części-znaczącej-liczby">14.
Dlaczego w zapisie liczb zmiennopozycyjnych IEEE754 nie ma potrzeby
przechowywania części całkowitej części znaczącej liczby?</a></li>
<li><a href="#podać-postaci-binarne-słów-32-bitowych-reprezentujących-liczby--256--19--10.125--0.75-0.625-10-15.5-16.5-w-zapisie-zmiennopozycyjnym-ieee-binary32.">15.
Podać postaci binarne słów 32-bitowych reprezentujących liczby -256,
-19, -10.125, -0.75, 0.625, 10, 15.5, 16.5 w zapisie zmiennopozycyjnym
IEEE binary32.</a></li>
<li><a href="#w-jaki-sposób-można-zmienić-znak-liczby-zapisanej-w-kodzie-u2-używając-wyłącznie-jednoargumentowych-operacji-logicznych-i-arytmetycznych">16.
W jaki sposób można zmienić znak liczby zapisanej w kodzie U2 używając
wyłącznie jednoargumentowych operacji logicznych i
arytmetycznych?</a></li>
<li><a href="#w-jaki-sposób-wykrywa-się-nadmiar-podczas-dodawania-liczb-w-kodzie-nkb-a-jak-podczas-dodawania-liczb-w-kodzie-u2">17.
W jaki sposób wykrywa się nadmiar podczas dodawania liczb w kodzie NKB,
a jak podczas dodawania liczb w kodzie U2?</a></li>
<li><a href="#narysować-układ-pól-struktury-o-podanej-deklaracji-w-języku-c-i-określić-wartość-operatora-sizeof-dla-tej-struktury-przyjmując-naturalne-rozmiary-typów-dla-32-bitowego-procesora-z-8-bitowymi-bajtami.-poprawność-rozwiązania-można-sprawdzić-pisząc-program-w-języku-c-wyświetlający-wartości-sizeof-dla-struktury-i-offsetof-dla-poszczególnych-jej-pól">19.
Narysować układ pól struktury o podanej deklaracji w języku C i określić
wartość operatora sizeof dla tej struktury, przyjmując naturalne
rozmiary typów dla 32-bitowego procesora z 8-bitowymi bajtami.
(Poprawność rozwiązania można sprawdzić pisząc program w języku C
wyświetlający wartości sizeof dla struktury i offsetof dla
poszczególnych jej pól)</a></li>
<li><a href="#dla-podanej-deklaracji-struktury-w-języku-c-podać-wartość-operatora-offsetof-przemieszczenie-pola-struktury-względem-początku-struktury-przyjmując-naturalne-rozmiary-typów-dla-32-bitowego-procesora-z-8-bitowymi-bajtami.-poprawność-rozwiązania-można-sprawdzić-pisząc-program-w-języku-c-wyświetlający-wartości-sizeof-dla-struktury-i-offsetof-dla-poszczególnych-jej-pól.">20.
Dla podanej deklaracji struktury w języku C podać wartość operatora
offsetof – przemieszczenie pola struktury względem początku struktury,
przyjmując naturalne rozmiary typów dla 32-bitowego procesora z
8-bitowymi bajtami. (Poprawność rozwiązania można sprawdzić pisząc
program w języku C wyświetlający wartości sizeof dla struktury i
offsetof dla poszczególnych jej pól).</a></li>
<li><a href="#naszkicować-orientacyjną-mapę-przestrzeni-adresowej-procesu-użytkowego-w-kilku-systemach-operacyjnych-na-podstawie-wartości-adresów-obiektów-należących-do-różnych-sekcji-wyświetlanych-przez-program-napisany-w-języku-c.">21.
Naszkicować orientacyjną mapę przestrzeni adresowej procesu użytkowego w
kilku systemach operacyjnych na podstawie wartości adresów obiektów
należących do różnych sekcji, wyświetlanych przez program napisany w
języku C.</a></li>
<li><a href="#na-podstawie-mapy-z-poprzedniego-zadania-oszacować-czy-dany-system-operacyjny-narzuca-istotne-ograniczenie-na-rozmiar-sterty-i-stosu-wynikające-z-samych-wartości-adresów-poszczególnych-sekcji.">22.
Na podstawie mapy z poprzedniego zadania oszacować, czy dany system
operacyjny narzuca istotne ograniczenie na rozmiar sterty i stosu,
wynikające z samych wartości adresów poszczególnych sekcji.</a></li>
<li><a href="#znając-wartość-danej-32-bitowej-oraz-jej-adres-określić-adresy-i-wartości-poszczególnych-jej-bajtów-przy-konwencji-adresowania-little-endian-i-big-endian">23.
Znając wartość danej 32-bitowej oraz jej adres określić adresy i
wartości poszczególnych jej bajtów przy konwencji adresowania
little-endian i big-endian</a></li>
</ul></li>
<li><a href="#użytkowy-model-programowy">Użytkowy model programowy</a>
<ul>
<li><a href="#co-wskazuje-rejestr-pc-podczas-wykonywania-instrukcji-po-jej-pobraniu">24.
Co wskazuje rejestr PC podczas wykonywania instrukcji (po jej
pobraniu)?</a></li>
<li><a href="#wymienić-i-scharakteryzować-sekcje-pamięci-programu-jednowątkowego-czas-życia-rozmiar-stałyzmienny-zawartość.">25.
Wymienić i scharakteryzować sekcje pamięci programu jednowątkowego (czas
życia, rozmiar stały/zmienny, zawartość).</a></li>
<li><a href="#opisać-czynności-wykonywane-kolejno-przez-procesor-podczas-wykonania-instrukcji-push-i-pop-na-stosie-pełnym-schodzącym.">27.
Opisać czynności wykonywane kolejno przez procesor podczas wykonania
instrukcji PUSH i POP na stosie „pełnym schodzącym”.</a></li>
<li><a href="#opisać-czynności-wykonywane-kolejno-przez-procesor-podczas-wykonania-instrukcji-push-i-pop-na-stosie-pustym-wchodzącym.">28.
Opisać czynności wykonywane kolejno przez procesor podczas wykonania
instrukcji PUSH i POP na stosie „pustym wchodzącym”.</a></li>
<li><a href="#znając-wartość-danej-32-bitowej-oraz-wartość-początkową-wskaźnika-stosu-określić-adresy-i-wartości-poszczególnych-jej-bajtów-po-umieszczeniu-jej-na-stosie-pełnym-schodzącym-przez-procesor-działający-w-konwencji-little-endian.">29.
Znając wartość danej 32-bitowej oraz wartość początkową wskaźnika stosu
określić adresy i wartości poszczególnych jej bajtów po umieszczeniu jej
na stosie „pełnym schodzącym” przez procesor działający w konwencji
little-endian.</a></li>
<li><a href="#na-czym-polega-wykonanie-instrukcji-skoku-ze-śladem">30.
Na czym polega wykonanie instrukcji skoku ze śladem?</a></li>
<li><a href="#jakie-instrukcje-procesora-są-używane-przez-kompilator-do-dzielenia-przez-potęgi-dwójki-liczbzapisanych-w-kodzie-ankb-bu2">31.
Jakie instrukcje procesora są używane przez kompilator do dzielenia
przez potęgi dwójki liczbzapisanych w kodzie (a)NKB (b)U2?</a></li>
<li><a href="#podać-wartość-dziesiętną-liczby-w-kodzie-u2-która-jest-wynikiem-wykonania-na-podanej-liczbie-np.--66--12-130-zapisanej-w-u2-operacji-przesunięcia-o-jeden-bit-a-logicznego-wlewo-b-logicznego-w-prawo-c-arytmetycznego-w-prawo.">32.
Podać wartość dziesiętną liczby w kodzie U2, która jest wynikiem
wykonania na podanej liczbie (np. -66, -12, 130) zapisanej w U2 operacji
przesunięcia o jeden bit (a) logicznego wlewo, (b) logicznego w prawo,
(c) arytmetycznego w prawo.</a></li>
<li><a href="#czym-różni-się-instrukcja-x86-sub-odejmowanie-od-cmp-porównanie">33.
Czym różni się instrukcja x86 SUB (odejmowanie) od CMP
(porównanie)?</a></li>
<li><a href="#dlaczego-adresowanie-ramki-stosu-przy-użyciu-wskaźnika-ramki-jest-na-ogół-wygodniejsze-niż-przy-użyciu-wskaźnika-stosu">34.
Dlaczego adresowanie ramki stosu przy użyciu wskaźnika ramki jest na
ogół wygodniejsze, niż przy użyciu wskaźnika stosu?</a></li>
<li><a href="#narysować-ramkę-stosu-funkcji-o-podanej-deklaracji-zgodnie-z-konwencją-wołania-x86-oraz-określić-adresy-argumentów-i-prawdopodobne-adresy-zmiennych-lokalnych-zakładając-że-obiekty-w-ramce-stosu-są-adresowane-względem-wskaźnika-ramki">35.
Narysować ramkę stosu funkcji o podanej deklaracji zgodnie z konwencją
wołania x86 oraz określić adresy argumentów i prawdopodobne adresy
zmiennych lokalnych, zakładając, że obiekty w ramce stosu są adresowane
względem wskaźnika ramki</a></li>
<li><a href="#jakie-tryby-adresowania-są-niezbędne-do-implementacji-języka-wysokiego-poziomu">36.
Jakie tryby adresowania są niezbędne do implementacji języka wysokiego
poziomu?</a></li>
<li><a href="#określić-nazwy-trybów-adresowania-argumentów-podanej-instrukcji-asemblerowej-x86.">37.
Określić nazwy trybów adresowania argumentów podanej instrukcji
asemblerowej x86.</a></li>
<li><a href="#jaką-informację-przechowuje-znacznik-parzystości">38. Jaką
informację przechowuje znacznik parzystości?</a></li>
<li><a href="#podać-wartości-znaczników-x86-po-wykonaniu-instrukcji-dodawaniaodejmowaniaoperacji-logicznej-o-podanych-wartościach-i-długości-argumentówwyniku.">39.
Podać wartości znaczników x86 po wykonaniu instrukcji
dodawania/odejmowania/operacji logicznej o podanych wartościach i
długości argumentów/wyniku.</a></li>
<li><a href="#na-czym-polega-ortogonalność-instrukcji-względem-trybów-adresowania">40.
Na czym polega ortogonalność instrukcji względem trybów
adresowania?</a></li>
<li><a href="#do-jakich-celów-kompilatory-języków-wysokiego-poziomu-używają-rejestrów-w-typowych-architekturach-cisc-a-do-jakich-w-risc">41.
Do jakich celów kompilatory języków wysokiego poziomu używają rejestrów
w typowych architekturach CISC, a do jakich w RISC?</a></li>
<li><a href="#dlaczego-programy-dla-procesorów-risc-na-ogół-zajmują-w-pamięci-więcej-miejsca-niż-równoważne-im-programy-dla-procesorów-cisc">42.
Dlaczego programy dla procesorów RISC na ogół zajmują w pamięci więcej
miejsca niż równoważne im programy dla procesorów CISC?</a></li>
<li><a href="#dlaczego-procesory-risc-nie-mają-zwykle-instrukcji-ładowania-do-rejestru-32-bitowej-danej-natychmiastowej-w-jaki-inny-sposób-może-być-zrealizowana-ta-operacja">43.
Dlaczego procesory RISC nie mają zwykle instrukcji ładowania do rejestru
32-bitowej danej natychmiastowej? W jaki inny sposób może być
zrealizowana ta operacja?</a></li>
<li><a href="#dlaczego-w-architekturach-risc-na-ogół-nie-występuje-instrukcja-powrotu-z-procedury-jaka-instrukcja-jest-używana-w-tych-architekturach-do-powrotu-z-procedur">44.
Dlaczego w architekturach RISC na ogół nie występuje instrukcja powrotu
z procedury? Jaka instrukcja jest używana w tych architekturach do
powrotu z procedur?</a></li>
<li><a href="#dlaczego-w-architekturze-risc-v-nie-ma-instrukcji-subi-odejmowania-stałej-natychmiastowej-bez-pułapki-przy-nadmiarze">45.
Dlaczego w architekturze RISC-V nie ma instrukcji SUBI – odejmowania
stałej natychmiastowej bez pułapki przy nadmiarze?</a></li>
<li><a href="#wymienić-nazwy-rejestrów-x86-w-trybie-32-bitowym-i-podać-funkcje-rejestrów-które-mają-sztywno-przypisane-zastosowanie.">46.
Wymienić nazwy rejestrów x86 (w trybie 32-bitowym) i podać funkcje
rejestrów, które mają sztywno przypisane zastosowanie.</a></li>
<li><a href="#jaka-instrukcja-procesorów-x86-służy-do-szybkiego-mnożenia-liczb-całkowitych-przez-3-5-i-9">47.
Jaka instrukcja procesorów x86 służy do szybkiego mnożenia liczb
całkowitych przez 3, 5 i 9?</a></li>
<li><a href="#jaki-częsty-błąd-programisty-popełniany-przy-programowaniu-asemblerowym-powoduje-sygnalizację-nadmiaru-dzielenia-w-procesorze-x86">48.
Jaki częsty błąd programisty, popełniany przy programowaniu
asemblerowym, powoduje sygnalizację nadmiaru dzielenia w procesorze
x86?</a></li>
<li><a href="#w-jakim-celu-w-jednostkach-wektorowych-wprowadzono-instrukcję-iloczynu-logicznego-z-negacją-jednego-z-argumentów">49.
W jakim celu w jednostkach wektorowych wprowadzono instrukcję iloczynu
logicznego z negacją jednego z argumentów?</a></li>
<li><a href="#jaką-postać-ma-wynik-instrukcji-porównania-danych-wykonywanej-przez-jednostkę-wektorową">50.
Jaką postać ma wynik instrukcji porównania danych wykonywanej przez
jednostkę wektorową?</a></li>
<li><a href="#instrukcja-pcmpeqb-jednostki-wektorowej-mmx-porównuje-dwa-64-bitowe-wektory-8-bitowych-liczb-całkowitych.-określić-wartość-wyniku-tej-instrukcji-dla-argumentów-źródłowych-0x11222334455667788-i-0x1111444466667777.">51.
Instrukcja PCMPEQB jednostki wektorowej MMX porównuje dwa 64-bitowe
wektory 8-bitowych liczb całkowitych. Określić wartość wyniku tej
instrukcji dla argumentów źródłowych 0x11222334455667788 i
0x1111444466667777.</a></li>
<li><a href="#czym-różni-się-w-zapisie-binarnym-i-wykonaniu-instrukcja-skoku-względnego-zwykle-określana-jako-branch-od-instrukcji-skoku-bezwzględnego-zwykle-nazywanej-jump">52.
Czym różni się w zapisie binarnym i wykonaniu instrukcja skoku
względnego (zwykle określana jako branch) od instrukcji skoku
bezwzględnego (zwykle nazywanej jump)?</a></li>
<li><a href="#w-jaki-sposób-kończy-się-wykonanie-programu-działającego-pod-kontrolą-systemu-operacyjnego-skąd-system-operacyjny-wie-która-instrukcja-programu-jest-ostatnią">53.
W jaki sposób kończy się wykonanie programu działającego pod kontrolą
systemu operacyjnego – skąd system operacyjny wie, która instrukcja
programu jest ostatnią</a></li>
</ul></li>
<li><a href="#jednostka-wykonawcza-procesora">Jednostka wykonawcza
procesora</a>
<ul>
<li><a href="#jakie-warunki-musi-spełniać-model-programowy-procesora-aby-możliwa-była-realizacja-tego-procesora-w-postaci-struktury-jednocyklowej">54.
Jakie warunki musi spełniać model programowy procesora, aby możliwa była
realizacja tego procesora w postaci struktury jednocyklowej?</a></li>
<li><a href="#jaką-operację-realizuje-jednostka-arytmetyczno-logiczna-podczas-wykonywania-instrukcji-ładowania-i-składowania-w-procesorze-jednocyklowym-i-w-prostych-procesorach-potokowych">55.
Jaką operację realizuje jednostka arytmetyczno-logiczna podczas
wykonywania instrukcji ładowania i składowania w procesorze
jednocyklowym i w prostych procesorach potokowych?</a></li>
<li><a href="#podać-przykład-sekwencji-instrukcji-generującej-hazard-typu-odczyt-po-zapisie-raw.">56.
Podać przykład sekwencji instrukcji generującej hazard typu odczyt po
zapisie (RAW).</a></li>
<li><a href="#dlaczego-usuwanie-hazardu-raw-przy-użyciu-obejść-jest-efektywniejsze-niż-przy-użyciu-innych-mechanizmów">57.
Dlaczego usuwanie hazardu RAW przy użyciu obejść jest efektywniejsze,
niż przy użyciu innych mechanizmów?</a></li>
<li><a href="#dlaczego-hazardu-raw-przy-ładowaniu-danej-z-pamięci-nie-można-usunąć-bez-wprowadzenia-opóźnienia">58.
Dlaczego hazardu RAW przy ładowaniu danej z pamięci nie można usunąć bez
wprowadzenia opóźnienia?</a></li>
<li><a href="#skąd-bierze-się-opóźnienie-skoków-w-architekturach-potokowych">59.
Skąd bierze się opóźnienie skoków w architekturach potokowych?</a></li>
<li><a href="#co-to-jest-skok-opóźniony">60. Co to jest skok
opóźniony?</a></li>
<li><a href="#dlaczego-skoków-opóźnionych-nie-stosuje-się-w-architekturach-o-długich-potokach">61.
Dlaczego skoków opóźnionych nie stosuje się w architekturach o długich
potokach?</a></li>
<li><a href="#wymienić-dwa-sposoby-potokowych-realizacji-modeli-programowych-cisc.">62.
Wymienić dwa sposoby potokowych realizacji modeli programowych
CISC.</a></li>
<li><a href="#w-jakich-procesorach-występuje-transkoder-instrukcji-i-na-czym-polega-jego-działanie">63.
W jakich procesorach występuje transkoder instrukcji i na czym polega
jego działanie?</a></li>
<li><a href="#kiedy-procesor-superskalarny-może-równocześnie-rozpocząć-wykonanie-dwóch-lub-większej-liczby-instrukcji">64.
Kiedy procesor superskalarny może równocześnie rozpocząć wykonanie dwóch
lub większej liczby instrukcji?</a></li>
<li><a href="#w-jakich-architekturach-występują-hazardy-war-i-waw-w-jaki-sposób-można-je-usunąć">65.
W jakich architekturach występują hazardy WAR i WAW? W jaki sposób można
je usunąć?</a></li>
<li><a href="#dlaczego-opóźnienie-skoków-i-opóźnienie-ładowania-danych-mają-duży-wpływ-na-wydajność-współczesnych-procesorów">66.
Dlaczego opóźnienie skoków i opóźnienie ładowania danych mają duży wpływ
na wydajność współczesnych procesorów?</a></li>
<li><a href="#na-czym-polega-fuzja-instrukcji-spotykana-we-współczesnych-procesorach-x86-podać-przykład-instrukcji-które-mogą-podlegać-fuzji">67.
Na czym polega fuzja instrukcji spotykana we współczesnych procesorach
x86? Podać przykład instrukcji, które mogą podlegać fuzji</a></li>
</ul></li>
<li><a href="#kieszenie">Kieszenie</a>
<ul>
<li><a href="#co-to-jest-linia-kieszeni">68. Co to jest linia
kieszeni?</a></li>
<li><a href="#opisać-optymalny-algorytm-wyznaczania-ofiar-w-kieszeni.">69.
Opisać optymalny algorytm wyznaczania ofiar w kieszeni.</a></li>
<li><a href="#podać-przykłady-fragmentów-programów-przy-wykonaniu-których-zastosowanie-kieszeni-asocjacyjnej-z-algorytmem-lru-do-wyznaczania-ofiar-daje-wyniki-znaczne-gorszelepsze-niż-zastosowanie-kieszeni-bezpośrednio-adresowanej.">70.
Podać przykłady fragmentów programów, przy wykonaniu których
zastosowanie kieszeni asocjacyjnej z algorytmem LRU do wyznaczania ofiar
daje wyniki znaczne gorsze/lepsze niż zastosowanie kieszeni bezpośrednio
adresowanej.</a></li>
<li><a href="#określić-które-bity-adresu-służą-do-adresowania-danych-wewnątrz-linii-które-do-wyboru-zbioru-a-które-są-używane-w-znacznikach-adresów-znając-całkowitą-pojemność-kieszeni-jej-asocjacyjność-i-długość-linii.-przyjmujemy-że-przy-dostępie-do-kieszeni-używa-się-adresów-wirtualnych.">71.
Określić, które bity adresu służą do adresowania danych wewnątrz linii,
które do wyboru zbioru, a które są używane w znacznikach adresów znając
całkowitą pojemność kieszeni, jej asocjacyjność i długość linii.
(Przyjmujemy, że przy dostępie do kieszeni używa się adresów
wirtualnych.)</a></li>
<li><a href="#od-czego-zależy-współczynnik-trafień-kieszeni">72. Od
czego zależy współczynnik trafień kieszeni?</a></li>
<li><a href="#podać-wzór-na-średni-czas-dostępu-hierarchii-pamięci-złożonej-z-dwóch-poziomów-kieszeni-i-pamięci-operacyjnej.">73.
Podać wzór na średni czas dostępu hierarchii pamięci złożonej z dwóch
poziomów kieszeni i pamięci operacyjnej.</a></li>
<li><a href="#obliczyć-średni-czas-dostępu-do-hierarchii-pamięci-o-podanych-parametrach-czasy-dostępu-współczynniki-trafień-kieszeni.">74.
Obliczyć średni czas dostępu do hierarchii pamięci o podanych
parametrach (czasy dostępu, współczynniki trafień kieszeni).</a></li>
<li><a href="#jakie-przesłania-danych-mają-miejsce-w-przypadku-chybienia-odczytu-kieszeni-l1-powodującego-chybienietrafienie-w-kieszeni-l2-jeśli-kieszenie-te-współpracują-na-zasadzie-inkluzywnejwyłącznej">75.
Jakie przesłania danych mają miejsce w przypadku chybienia odczytu
kieszeni L1 powodującego chybienie/trafienie w kieszeni L2, jeśli
kieszenie te współpracują na zasadzie inkluzywnej/wyłącznej?</a></li>
<li><a href="#podać-przykład-sytuacji-operacji-wykonywanych-w-programie-gdy-kieszeń-z-alokacją-linii-przy-chybieniu-zapisu-wbwa-będzie-działać-wolniej-niż-kieszeń-bez-alokacji-wbnwa.">76.
Podać przykład sytuacji (operacji wykonywanych w programie), gdy kieszeń
z alokacją linii przy chybieniu zapisu (WB/WA) będzie działać wolniej,
niż kieszeń bez alokacji (WB/NWA).</a></li>
<li><a href="#kiedy-może-wystąpić-niespójność-zawartości-kieszeni-i-pamięci-operacyjnej">77.
Kiedy może wystąpić niespójność zawartości kieszeni i pamięci
operacyjnej?</a></li>
</ul></li>
<li><a href="#zarządzanie-zasobami">Zarządzanie zasobami</a>
<ul>
<li><a href="#na-czym-polega-ochrona-procesora">78. Na czym polega
ochrona procesora?</a></li>
<li><a href="#wymienić-funkcje-zadania-systemu-zarządzania-pamięcią.">79.
Wymienić funkcje (zadania) systemu zarządzania pamięcią.</a></li>
<li><a href="#na-czym-polega-i-do-czego-służy-sprzętowa-relokacja-adresów">80.
Na czym polega i do czego służy sprzętowa relokacja adresów?</a></li>
<li><a href="#dlaczego-adresy-logiczne-o-wartościach-bliskich-0-nie-są-na-ogół-dostępne-dla-programów-użytkowych-we-współczesnych-systemach-operacyjnych">81.
Dlaczego adresy logiczne o wartościach bliskich 0 nie są na ogół
dostępne dla programów użytkowych we współczesnych systemach
operacyjnych?</a></li>
<li><a href="#jakie-informacje-zawiera-deskryptor-segmentustrony">82.
Jakie informacje zawiera deskryptor segmentu/strony?</a></li>
<li><a href="#w-jaki-sposób-jednostka-segmentacji-generuje-adres-liniowy">83. W
jaki sposób jednostka segmentacji generuje adres liniowy?</a></li>
<li><a href="#co-oznaczają-bity-dostępu-i-modyfikacji-w-deskryptorze-strony-kiedy-i-przez-co-są-one-zerowane-i-ustawiane-w-stan-1">84.
Co oznaczają bity dostępu i modyfikacji w deskryptorze strony? Kiedy i
przez co są one zerowane i ustawiane w stan 1?</a></li>
<li><a href="#w-jakich-sytuacjach-jednostka-segmentacjistronicowania-zgłasza-błąd-segmentustrony">85.
W jakich sytuacjach jednostka segmentacji/stronicowania zgłasza błąd
segmentu/strony?</a></li>
<li><a href="#dlaczego-do-przechowywania-deskryptorów-stron-używa-się-struktur-tablicowo-drzewiastych-a-nie-zwykłych-wektorów">86.
Dlaczego do przechowywania deskryptorów stron używa się struktur
tablicowo-drzewiastych, a nie zwykłych wektorów?</a></li>
<li><a href="#co-to-jest-table-walk">87. Co to jest „table
walk”?</a></li>
<li><a href="#skąd-bierze-się-wysoki-koszt-czasowy-chybień-bufora-translacji">88.
Skąd bierze się wysoki koszt czasowy chybień bufora translacji?</a></li>
<li><a href="#jakie-deskryptory-stron-są-oznaczone-jako-globalne-i-jakie-znaczenie-ma-ten-atrybut-deskryptora">89.
Jakie deskryptory stron są oznaczone jako globalne i jakie znaczenie ma
ten atrybut deskryptora?</a></li>
<li><a href="#jakie-pola-zawiera-nieważny-deskryptor-strony">90. Jakie
pola zawiera nieważny deskryptor strony?</a></li>
<li><a href="#dlaczego-rozróżnienie-prawa-dostępu-do-odczytu-danych-i-do-pobrania-instrukcji-wjednostce-zarządzania-pamięcią-podnosi-bezpieczeństwo-systemu">91.
Dlaczego rozróżnienie prawa dostępu do odczytu danych i do pobrania
instrukcji wjednostce zarządzania pamięcią podnosi bezpieczeństwo
systemu?</a></li>
<li><a href="#jednostka-stronicowania-procesora-przechowuje-deskryptory-stron-w-strukturze-tablicowo-drzewiastej-w-której-tablice-mają-rozmiar-strony.-podstawowy-rozmiar-strony-jest-równy-p-a-rozmiar-deskryptora-d.-określić-kolejno-następujące-parametry-jednostki-stronicowania-translującej-adres-wirtualny-nie-krótszy-niż-a-bitów--minimalną-liczbę-poziomów-struktury-tablicowo-drzewiastej--maksymalną-długość-adresu-wirtualnego-przy-tej-liczbie-poziomów--budowę-adresu-wirtualnego-jego-podział-na-indeksy-tablic-i-adres-wewnątrztrzstronicowy--możliwe-rozmiary-dużych-stron.przykładowe-dane-a-p-8-kib-d-8-b-a-40-b-p-16-kib-d-8-b-a-48-c-p-8-kib-d-4-b-a-32.">92.
Jednostka stronicowania procesora przechowuje deskryptory stron w
strukturze tablicowo-drzewiastej, w której tablice mają rozmiar strony.
Podstawowy rozmiar strony jest równy p, a rozmiar deskryptora –
d. Określić kolejno następujące parametry jednostki stronicowania,
translującej adres wirtualny nie krótszy niż a bitów:- minimalną liczbę
poziomów struktury tablicowo-drzewiastej,- maksymalną długość adresu
wirtualnego przy tej liczbie poziomów,- budowę adresu wirtualnego – jego
podział na indeksy tablic i adres wewnątrztrzstronicowy,- możliwe
rozmiary „dużych” stron.Przykładowe dane: a) p = 8 KiB, d = 8 B, a = 40;
b) p = 16 KiB, d = 8 B, a = 48; c) p = 8 KiB, d = 4 B, a = 32.</a></li>
<li><a href="#przyjmując-parametry-jednostki-stronicowania-z-poprzedniego-zadania-oszacować-całkowity-rozmiar-prywatnych-tablic-deskryptorów-stron-najmniejszego-procesu-użytkowego-korzystającego-ze-sterty-przy-założeniu-że-każda-z-czterech-sekcji-pamięci-procesu-jest-opisana-oddzielną-tablicą-stron-o-rozmiarze-podstawowym.">93.
Przyjmując parametry jednostki stronicowania z poprzedniego zadania,
oszacować całkowity rozmiar prywatnych tablic deskryptorów stron
najmniejszego procesu użytkowego korzystającego ze sterty, przy
założeniu, że każda z czterech sekcji pamięci procesu jest opisana
oddzielną tablicą stron o rozmiarze podstawowym.</a></li>
</ul></li>
<li><a href="#wyjątki">Wyjątki</a>
<ul>
<li><a href="#co-to-jest-wyjątek">94. Co to jest wyjątek?</a></li>
<li><a href="#wymienić-i-scharakteryzować-poszczególne-klasy-wyjątków-podać-po-kilka-przykładów-wyjątków-poszczególnych-klas.">95.
Wymienić i scharakteryzować poszczególne klasy wyjątków, podać po kilka
przykładów wyjątków poszczególnych klas.</a></li>
<li><a href="#czym-różni-się-obsługa-przerwań-od-obsługi-innych-wyjątków">96.
Czym różni się obsługa przerwań od obsługi innych wyjątków?</a></li>
<li><a href="#co-wskazuje-wartość-licznika-instrukcji-zapamiętywana-podczas-obsługi-wyjątków-poszczególnych-typów">97.
Co wskazuje wartość licznika instrukcji zapamiętywana podczas obsługi
wyjątków poszczególnych typów?</a></li>
<li><a href="#dlaczego-do-wywoływania-usług-systemowych-przez-program-użytkowy-nie-można-użyć-instrukcji-skoku-ze-śladem">98.
Dlaczego do wywoływania usług systemowych przez program użytkowy nie
można użyć instrukcji skoku ze śladem?</a></li>
<li><a href="#czym-różni-się-instrukcja-powrotu-z-obsługi-wyjątku-od-instrukcji-powrotu-ze-zwykłej-procedury.">99.
Czym różni się instrukcja powrotu z obsługi wyjątku od instrukcji
powrotu ze zwykłej procedury.</a></li>
<li><a href="#w-jaki-sposób-zmienia-się-priorytet-procesora-podczas-obsługi-przerwania">100.
W jaki sposób zmienia się priorytet procesora podczas obsługi
przerwania?</a></li>
<li><a href="#jaka-relacja-musi-zachodzić-pomiędzy-priorytetem-przerwania-i-priorytetem-procesora-aby-przerwanie-mogło-zostać-obsłużone">101.
Jaka relacja musi zachodzić pomiędzy priorytetem przerwania i
priorytetem procesora, aby przerwanie mogło zostać obsłużone?</a></li>
<li><a href="#co-to-jest-późne-przybycie-przerwania">102. Co to jest
„późne przybycie” przerwania?</a></li>
<li><a href="#na-czym-polega-łańcuchowanie-przerwań-zrealizowane-w-architekturze-armv6v7">103.
Na czym polega łańcuchowanie przerwań, zrealizowane w architekturze
ARMv6/v7?</a></li>
<li><a href="#wyjaśnić-różnicę-pomiędzy-poziomem-zaufania-i-priorytetem-procesora.">104.
Wyjaśnić różnicę pomiędzy poziomem zaufania i priorytetem
procesora.</a></li>
<li><a href="#jakie-informacje-są-zapamiętywane-przez-procesor-podczas-obsługi-błędu-strony">105.
Jakie informacje są zapamiętywane przez procesor podczas obsługi błędu
strony?</a></li>
<li><a href="#na-czym-polega-restart-instrukcji-stosowany-przy-obsłudze-błędów">106.
Na czym polega restart instrukcji, stosowany przy obsłudze
błędów?</a></li>
<li><a href="#dlaczego-we-współczesnych-architekturach-przy-obsłudze-błędów-przez-procesor-używa-się-metody-restartu-instrukcji-a-nie-kontynuacji">107.
Dlaczego we współczesnych architekturach przy obsłudze błędów przez
procesor używa się metody restartu instrukcji, a nie
kontynuacji?</a></li>
<li><a href="#jaki-jest-skutek-wykonania-przez-program-użytkowy-instrukcji-powrotu-z-obsługi-wyjątku">108.
Jaki jest skutek wykonania przez program użytkowy instrukcji powrotu z
obsługi wyjątku?</a></li>
<li><a href="#co-to-jest-błąd-podwójny">109. Co to jest błąd
podwójny?</a></li>
<li><a href="#co-to-jest-przechwycenie">110. Co to jest
przechwycenie?</a></li>
<li><a href="#wyjaśnić-zasadę-ataku-typu-buffer-overflow-i-rolę-atrybutu-strony-executable-w-zapobieganiu-tego-typu-atakom.">111.
Wyjaśnić zasadę ataku typu buffer overflow i rolę atrybutu strony
executable w zapobieganiu tego typu atakom.</a></li>
</ul></li>
<li><a href="#pamięć-wirtualna">Pamięć wirtualna</a>
<ul>
<li><a href="#jakie-mechanizmy-musi-udostępniać-procesor-aby-mógł-on-pracować-w-systemie-pamięci-wirtualnej">112.
Jakie mechanizmy musi udostępniać procesor, aby mógł on pracować w
systemie pamięci wirtualnej?</a></li>
<li><a href="#opisać-rolę-poszczególnych-składników-sprzętowych-i-programowych-w-implementacji-pamięci-wirtualnej.">113.
Opisać rolę poszczególnych składników sprzętowych i programowych w
implementacji pamięci wirtualnej.</a></li>
<li><a href="#kiedy-strona-zaalokowana-dla-procesu-przez-system-operacyjny-może-mieć-nieważny-deskryptor">114.
Kiedy strona zaalokowana dla procesu przez system operacyjny może mieć
nieważny deskryptor?</a></li>
<li><a href="#na-czym-polega-leniwa-alokacja-pamięci">115. Na czym
polega „leniwa” alokacja pamięci?</a></li>
<li><a href="#co-to-jest-aliasowanie-deskryptorów">116. Co to jest
aliasowanie deskryptorów?</a></li>
</ul></li>
<li><a href="#wejście-wyjście">Wejście-wyjście</a>
<ul>
<li><a href="#dlaczego-we-współczesnych-komputerach-uniwersalnych-w-zasadzie-nie-stosuje-się-obsługi-urządzeń-wejścia-wyjścia-przy-użyciu-aktywnego-oczekiwania">117.
Dlaczego we współczesnych komputerach uniwersalnych w zasadzie nie
stosuje się obsługi urządzeń wejścia-wyjścia przy użyciu aktywnego
oczekiwania?</a></li>
<li><a href="#jakie-urządzenia-wejścia-wyjścia-wymagają-obsługi-przy-użyciu-bezpośredniego-dostępu-do-pamięci-scharakteryzować-cechy-takich-urządzeń">118.
Jakie urządzenia wejścia-wyjścia wymagają obsługi przy użyciu
bezpośredniego dostępu do pamięci (scharakteryzować cechy takich
urządzeń)?</a></li>
<li><a href="#wymienić-rejestry-kanału-bezpośredniego-dostępu-do-pamięci-i-opisać-sposób-ich-zaprogramowania-przez-system-operacyjny-oraz-modyfikacji-przez-sprzęt-podczas-transmisji.">119.
Wymienić rejestry kanału bezpośredniego dostępu do pamięci i opisać
sposób ich zaprogramowania przez system operacyjny oraz modyfikacji
przez sprzęt podczas transmisji.</a></li>
<li><a href="#wyjaśnić-z-czego-wynikają-ograniczenia-żywotności-popularnych-urządzeń-pamięci-masowej-stałych-dysków-magnetycznych-i-urządzeń-półprzewodnikowych-ssd-karty-pamięci">120.
Wyjaśnić z czego wynikają ograniczenia żywotności popularnych urządzeń
pamięci masowej – stałych dysków magnetycznych i urządzeń
półprzewodnikowych (SSD, karty pamięci)</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
    </div>
</div>
</body>
</html>
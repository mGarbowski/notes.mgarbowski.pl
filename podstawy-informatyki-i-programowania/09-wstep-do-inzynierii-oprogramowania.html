<!doctype html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>09-wstep-do-inzynierii-oprogramowania</title>
    <link rel="stylesheet" href="../style.css">

    <!--    Load mathjax from cdn to render latex equations-->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
<div class="prev-next-links">
    
    <div class="index-links-prev">
        <a href="07-przeplyw-sterowania.html">Poprzedni: 07-przeplyw-sterowania.html</a>
    </div>
    

    
    <div class="index-links-next">
        <a href="09-wstep-do-inzynierii-oprogramowania.html">Następny: 09-wstep-do-inzynierii-oprogramowania.html</a>
    </div>
    
    <div class="return-link">
        <a href="..">Powrót</a>
    </div>
</div>
<div class="container">
    <div class="index-links-wrapper">
        <h2>Podstawy informatyki i programowania</h2>
        <div class="index-links">
            <ul>
                
                <li><a href="00-wstep.html">00-wstep.html</a></li>
                
                <li><a href="01-podstawy.html">01-podstawy.html</a></li>
                
                <li><a href="02-architektura-komputera.html">02-architektura-komputera.html</a></li>
                
                <li><a href="03-arytmetyka-u2.pdf">03-arytmetyka-u2.pdf</a></li>
                
                <li><a href="03-liczby-calkowite.html">03-liczby-calkowite.html</a></li>
                
                <li><a href="04-liczby-rzeczywiste.html">04-liczby-rzeczywiste.html</a></li>
                
                <li><a href="05-znaki-i-napisy.html">05-znaki-i-napisy.html</a></li>
                
                <li><a href="06-algorytmy.html">06-algorytmy.html</a></li>
                
                <li><a href="07-przeplyw-sterowania.html">07-przeplyw-sterowania.html</a></li>
                
                <li><a href="08-funkcje-stos-pamiec-w-procesie.html">08-funkcje-stos-pamiec-w-procesie.html</a></li>
                
                <li><a href="09-wstep-do-inzynierii-oprogramowania.html">09-wstep-do-inzynierii-oprogramowania.html</a></li>
                
                <li><a href="10-zlozonosc-obliczeniowa.html">10-zlozonosc-obliczeniowa.html</a></li>
                
                <li><a href="11-lingwistyka-matematyczna.html">11-lingwistyka-matematyczna.html</a></li>
                
                <li><a href="powtorzenie-do-kolokwium-01.html">powtorzenie-do-kolokwium-01.html</a></li>
                
                <li><a href="powtorzenie-do-kolokwium-02.html">powtorzenie-do-kolokwium-02.html</a></li>
                
            </ul>
        </div>
    </div>
    <div class="content-wrapper">
        <main>
            <p>Jeśli strona była dla Ciebie pomocna, możesz wesprzeć mnie w jej utrzymaniu na <a href="https://buycoffee.to/mgarbowski">buycoffee.to/mgarbowski</a></p>
            <h1 id="wstęp-do-inżynierii-oprogramowania">Wstęp do inżynierii
oprogramowania</h1>
<h2 id="metody-projektowania-programu">Metody projektowania
programu</h2>
<ul>
<li>Metoda wstępująca (bottom-up) - od szczegółu do ogółu</li>
<li>Metoda zstępująca (top-down) - od ogółu do szczegółu</li>
</ul>
<h2 id="paradygmaty-programowania">Paradygmaty programowania</h2>
<p>Paradygmat - wzorzec / przykład</p>
<p>Klasyfikacja pod względem sposobu patrzenia programisty na przepływ
sterowania programu. Język może wspierać różne paradygmaty
programowania.</p>
<h3 id="imperatywne">Imperatywne</h3>
<ul>
<li>programista instruuje komputer jak zmieniać stan</li>
<li>programista skupia się na tym jak coś wykonać</li>
<li>program jest sekwencją instrukcji do wykonania - control flow</li>
</ul>
<h3 id="deklaratywne">Deklaratywne</h3>
<ul>
<li>programista deklaruje jaki rezultat chce dostać, a nie jak go
uzyskać</li>
<li>programista skupia się na tym co wykonać</li>
<li>program jest zdefiniowaną logiką, a nie konkrenym przebiegiem
sterowania</li>
<li>np. SQL</li>
</ul>
<h2 id="paradygmaty-imperatywne">Paradygmaty imperatywne</h2>
<h3 id="proceduralne">Proceduralne</h3>
<p>Rozwinięcie koncepcji programowania strukturalnego o
modularyzację.</p>
<ul>
<li>Bloki instrukcji, instrukcje warunkowe, pętle, modularność</li>
<li>Są zmienne lokalne</li>
<li>Instrukcje są grupowane w procedury</li>
<li>Dekompozycja na procedury</li>
<li>Program ma swoją strukturę</li>
<li>Nie powinno być niestrukturalnych instrukcji (<code>goto</code>,
<code>break</code>, <code>continue</code>)</li>
</ul>
<p>Warunek pętli powinien być jedynym punktem określającym czy ma się
kontynuować lub przerwać</p>
<h3 id="obiektowe">Obiektowe</h3>
<p>Instrukcje są grupowane ze stanem (danymi), na którym operują.
Program to zbiór porozumiewających się ze sobą obiektów.</p>
<ul>
<li>Obiekt - jednostka zawierająca dane i operująca na nich</li>
<li>Odzwierciedla współpracę obiektów w świecie rzeczywistym</li>
<li>Dziedziczenie - definiowanie bardziej złożonych obiektów na bazie
istniejących</li>
<li>Klasy (typy) i obiekty (instancje)</li>
<li>Metody - procedury, które operują na wewnętrznych atrybutach
klasy</li>
<li>Programista określa kto co może zrobić
<ul>
<li>Można np. nie pozwolić na podanie niepoprawnych danych</li>
</ul></li>
</ul>
<h2 id="paradygmaty-deklaratywne">Paradygmaty deklaratywne</h2>
<h3 id="funkcyjne">Funkcyjne</h3>
<p>Rezultat jest deklarowany przez serię aplikowanych funkcji (złożenie
funkcji jak funkcji matematycznych)</p>
<ul>
<li>Nie ma zmiennych, jest rekursja</li>
<li>Cały program jest złożoną funkcją, której wartość oblicza się z
danych wejściowych</li>
<li>wywołanie funkcji na samym końcu</li>
<li>Funkcje wyższego rzędu - użycie funkcji jako argumentów /
wyników</li>
<li>Leniwe obliczanie (lazy evaluation)</li>
<li>np. Haskell, Scala, F#</li>
</ul>
<h3 id="logiczne">Logiczne</h3>
<p>Rezultat deklarowany jako odpowiedź na pytanie oparte o system faktów
i reguł</p>
<p>np. Prolog</p>
<h3 id="programowanie-sterowane-danymi-data-flow">Programowanie
sterowane danymi (data flow)</h3>
<p>Program to graf operacji między którymi przepływają dane</p>
<ul>
<li>Moment wykonania operacji nie zależy od kolejności instrukcji, tylko
od dostępności danych</li>
<li>Analogicznie do arkusza kalkulacyjnego</li>
<li>AHDL - definiuje strukturę układu, a nie kiedy co się stanie
<ul>
<li>W układzie wszystko dzieje się równolegle</li>
</ul></li>
<li>np. LabVIEW, Verilog, VHDL, AHDL, TensorFlow</li>
</ul>
<h2 id="inne-paradygmaty">Inne paradygmaty</h2>
<h3 id="programowanie-zdarzeniowe-event-driven">Programowanie
zdarzeniowe (event-driven)</h3>
<p>Program jest zbiorem procedur (handler) reagujących na zdarzenia
(zewnętrzne i wewnętrzne)</p>
<ul>
<li>Sekwencje zdarzeń (Kliknięcie przycisku, ruch myszką, upływ czasu
itp.)</li>
<li>Wymaga dodatkowego zarządcy, sterującego wykonywaniem procedur
<ul>
<li>kolejka zdarzeń</li>
</ul></li>
<li>Handler nie pamięta jaki ciąg zdarzeń doprowadził do obsługi danego
zdarzenia</li>
<li>Sekwencja zdarzeń to język (ma strukturę gramatyczną)</li>
<li>Stan okna GUI jest stanem automatu popychanego zdarzeniami</li>
<li>np. obsługa GUI, aplikacje klient-serwer</li>
</ul>
<h3 id="programowanie-współbieżne-concurrent">Programowanie współbieżne
(concurrent)</h3>
<p>Program to zbiór współbieżnych elementów (procesów / zadań / wątków)
wykonujących się równocześnie</p>
<ul>
<li>Wiele procesów - każdy ma oddzielną pamięć, proces może się
rozgałęzić i wystartować kolejne</li>
<li>Wiele wątków - w ramach jednego procesu, na jednym rdzeniu
procesora, dzielona pamięć w ramach procesu</li>
<li>Wersja ze wspólną pamięcią lub z komunikatami</li>
<li>Nacisk na zależności między elementami (więzy i zakazy)</li>
<li>Wymaga synchronizacji i zapobiegania hazardom między elementami
wykonującymi się równocześnie</li>
<li>Może być realizowane przez biblioteki do języków, bo systemy
operacyjne natywnie wspierają procesy i wątki</li>
<li>Może być nałożone np. na model imperatywny, obiektowy i inne</li>
</ul>
<h3 id="data-driven-programming">Data-driven programming</h3>
<p>Instrukcje opisują wzorce danych, w momencie dopasowania wyzwolą
określone przetwarzanie</p>
<ul>
<li>Podobne do programowania zdarzeniowego</li>
<li>Przetwarzanie strumieni danych</li>
<li>Filtrowanie, agregowanie</li>
<li>np. AWK, sed, Lua</li>
</ul>
<h3 id="programowanie-aspektowe-aspect-oriented">Programowanie aspektowe
(aspect-oriented)</h3>
<p>Paradygmat zwiększający modularność programu przez separację
zagadnień. Zamiast modyfikować kod realizujący daną funkcjonalność
dodaje się aspekt.</p>
<ul>
<li>Punkt przecięcia (pointcut) - np. dotyczy wszystkich metod o
określonej nazwie</li>
<li>Porada (advice) - funkcje wywołane w określonych punktach
przecięcia</li>
</ul>
<p>Może być zrealizowane statycznie lub dynamicznie - podczas kompilacji
lub podczas wykonywania</p>
<h2 id="podstawowe-założenia-oop">Podstawowe założenia OOP</h2>
<h3 id="dziedziczenie">Dziedziczenie</h3>
<p>Budowanie hierarchii typów obiektów, z których obiekt dziedziczący
posiada wszystkie cechy obiektu bazowego.</p>
<h3 id="abstrakcja">Abstrakcja</h3>
<p>Każdy obiekt może ukrywać przed innymi swoje szczegóły
implementacyjne.</p>
<ul>
<li>Klasy dziedziczące mogą być zaimplementowane inaczej</li>
<li>Publicznie dostępny interfejs nie powinien pozwolić na stworzenie
obiektu z niespójnym stanem</li>
</ul>
<h3 id="hermetyzacja-enkapsulacja">Hermetyzacja (enkapsulacja)</h3>
<p>Tylko sam obiekt może dokonywać zmian na swoim stanie
wewnętrznym.</p>
<p>Na zewnątrz udostępnia swój interfejs, żeby inne obiekty mogły
zmieniać jego stan w kontrolowany sposób.</p>
<h3 id="polimorfizm">Polimorfizm</h3>
<p>Referencja na obiekt może dotyczyć dowolnego typu obiektu z
hierarchii dziedziczenia.</p>
<ul>
<li>Dynamicznie ustala się z której klasy zostanie wywołana metoda
(dowiązanie późne)</li>
<li>Koszt wywołania nie jest “deterministycznie” znany - trzeba za
każdym razem znaleźć, gdzie jest implementacja, którą należy
wywołać</li>
</ul>
<h2 id="data-oriented-design">Data-oriented design</h2>
<p>Optymalizacja danych w celu najefektywniejszego wykorzystania zasobów
(np. sprzętu)</p>
<ul>
<li>Organizacja bloków danych do przetwarzania wektorowego na karcie
graficznej (SIMD)</li>
<li>Organizacja danych i przetwarzania w celu optymalnego wykorzystania
cache’y</li>
</ul>
<h2 id="refleksja">Refleksja</h2>
<p>Zdolność programu do badania swojej struktury, własności, typów
obiektów w trakcie wykonywania (introspekcja) i zdolność programu do
modyfikowania swojej struktury i zachowania.</p>
<h3 id="możliwości-refleksji">Możliwości refleksji</h3>
<ul>
<li>Odpytanie obiektu o listę atrybutów i metod</li>
<li>Modyfikacja struktury obiektu</li>
<li>Wywołanie metody na obiekcie</li>
<li>Tworzenie bibliotek i framework’ów
<ul>
<li>np. do serializacji / deserializacji danych</li>
</ul></li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>obj <span class="op">=</span> gloabals()[<span class="st">&#39;Foo&#39;</span>]()</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="bu">getattr</span>(obj, <span class="st">&#39;hello&#39;</span>)()</span></code></pre></div>
<p>Nie używać <code>eval</code>, najlepiej nigdy</p>
<h2 id="separacja-zagadnień-soc">Separacja zagadnień (SoC)</h2>
<p>Podział programu na odrębne moduły, które nie pokrywają się
funkcjonalnością</p>
<ul>
<li>Każdy element powinien mieć swoje unikalne zastosowanie</li>
<li>Każdy element zachowuje możliwość jak największej adaptacji do
zmian</li>
</ul>
<h3 id="zalety">Zalety</h3>
<ul>
<li>Uproszczona praca zespołowa</li>
<li>Łatwiejsza rozbudowa</li>
<li>Lepsza czytelność</li>
<li>Większa reużywalność kodu</li>
</ul>
<h3 id="dotyczy">Dotyczy</h3>
<ul>
<li>Architektury systemu</li>
<li>Architektury aplikacji - podział na warstwy
<ul>
<li>prezentacja</li>
<li>logika biznesowa</li>
<li>dostęp do danych</li>
</ul></li>
</ul>
<h3 id="problem-separacji-zagadnień">Problem separacji zagadnień</h3>
<p>Często poza główną logiką biznesową, program musi realizować też
jakąś logikę poboczną (np. logowanie)</p>
<ul>
<li>Implementacja zagadnienia może być porozrzucana (scattered) po wielu
modułach.</li>
<li>Implementacja zagadnienia może być splątana (tangled) z kodem
realizującym inne zagadnienia</li>
<li>Splątanie i porozrzucanie utrudniają albo uniemożliwiają
testowanie</li>
</ul>
<h2 id="zasady-solid">Zasady SOLID</h2>
<h3 id="single-responsibility-principle">Single Responsibility
Principle</h3>
<p>Odpowiedzialność to powód do zmiany - kiedy trzeba by zmienić kawałek
kodu. Jeśli powodów jest kilka, to funkcjonalności nie powinny być
splątane w jednej klasie/funkcji itp.</p>
<ul>
<li>Podział programu na elementy o pojedynczych odpowiedzialnościach
zwiększy ich reużywalność</li>
<li>Każdy element będzie łatwiejszy do zaimplementowania i
przetestowania</li>
</ul>
<h3 id="open-closed-principle">Open-Closed Principle</h3>
<p>Klasy, moduły, funkcje powinny być otwarte na rozszerzenia i
zamknięte na modyfikacje. Uzyskanie nowych funkcji powinno być możliwe
przez rozszerzenie elementu a nie przez zmianę już istniejącego elementu
(który może już być używany i nie można tego zepsuć).</p>
<ul>
<li>Zmniejsza ryzyko złamania kompatybilności</li>
<li>Dodanie funkcjonalności nie powinno wymuszać zmian w istniejących
elementach ani w testah jednostkowych</li>
<li>Można to osiągnąć przez wykorzystanie interfejsów albo dziedziczenia
(lepiej interfejsów)</li>
</ul>
<h3 id="liskov-substitution-principle">Liskov Substitution
Principle</h3>
<p>Funkcje, które używają referencji do klas bazowych muszą być w stanie
używać też obiektów klas dziedziczących po tych klasach bazowych bez
znajomości ich implementacji.</p>
<ul>
<li>Polimorfizm nie może zmieniać semantyki, przeciążone metody powinny
się zachowywać tak samo z punktu widzenia użytkownika</li>
<li>Klasa dziedzicząca nie powinna zmieniać funkcjonalności tylko ją
rozszerzać</li>
<li>Rule of Three - przy drugim kopiuj-wklej należy się już poważnie
zastanowić</li>
<li>Nie każda relacja “is a” musi oznaczać dziedziczenie
<ul>
<li>Gołąb i Pingwin są ptakami - bazowy ptak nie powinien mieć
możliwości latania</li>
</ul></li>
<li>Do tego są interfejsy</li>
</ul>
<h3 id="interface-segregation-principle">Interface Segregation
Principle</h3>
<p>Interfejsy powinny być odpowiedzialne za jak najmniejszą
funkcjonalność.</p>
<ul>
<li>Nowa klasa implementuje tylko te interfejsy, których potrzebuje</li>
<li>Fat / polluted interface - zawiera zbyt wiele metod, które nie będą
używane i wymaga ich zaimplementowania</li>
<li>Łączy się z zasadą Liskov</li>
</ul>
<h3 id="dependency-inversion-principle">Dependency Inversion
Principle</h3>
<p>Kod z warstw wyższego poziomu nie powinien zależeć od kodu z niższych
warstw. Obie warstwy powinny zależeć od abstrakcji (nie implementacji).
Implementacja (szczegóły) powinna zależeć od abstrakcji.</p>
<p>W ten sposób, można łatwo wymienić implementację jednej ze stron bez
konieczności wprowadzania zmian w drugiej i nie trzeba testować rzeczy,
które nie zostały ruszone.</p>
<p>Wstrzyknięcie zależności - podanie instancji klasy implementującej
wymagany interfejs (abstrakcję) jako parametr konstruktora.</p>
<p>Np. warstwa logiki biznesowej aplikacji zależy od abstrakcyjnej
warstwy utrwalania - podmieniając implementację umożliwia się współpracę
z różnymi bazami danych.</p>
<p>Wyższa / niższa warstwa - która używa (zależy od) której.</p>
<p>Przykład * Budowa kompilatora * obsługa tekstu źródłowego *
analizator leksykalny * analizator składniowy * analizator semantyczny *
optymalizator * generator kodu * Stos protokołów sieciowych * pakiety IP
można przesyłać gołębiami pocztowymi i reszta protokołów ze stosu dalej
działa</p>
<h2 id="dry---dont-repeat-yourself">DRY - Don’t repeat yourself</h2>
<p>Należy unikać powtarzania tych samych części kodu w różnych
miejscach.</p>
<ul>
<li>Uniknięcie kopiowania</li>
<li>Uniknięcie błędów, zaoszczędzenie czasu
<ul>
<li>Zmiana jest tylko w 1 miejscu</li>
<li>Nie trzeba szukać wszystkich miejsc</li>
</ul></li>
<li>Uniknięcie powtarzania czynności przez programistę
<ul>
<li>Skrypty</li>
<li>Generatory kodu</li>
</ul></li>
</ul>
<h3 id="realizacja-założeń-dry">Realizacja założeń DRY</h3>
<ul>
<li>Funkcje</li>
<li>Szablony / makra (języki silnie typowane)
<ul>
<li>Kompilator generuje kod</li>
</ul></li>
<li>Struktury</li>
<li>Klasy</li>
<li>Stałe</li>
<li>Moduły</li>
<li>Biblioteki</li>
</ul>
<h2 id="kiss---keep-it-simple-stupid">KISS - Keep It Simple, Stupid</h2>
<p>Nie należy komplikować prostych rzeczy.</p>
<p>Nie należy stosować na siłę wzorców projektowych tam gdzie to nie
jest potrzebne. Nie należy szukać lepszego rozwiązania dłużej niż można
na tym zaoszczędzić.</p>
<p>Skomplikowane rozwiązania i wzorce projektowe warto stosować kiedy
przynoszą jakąś korzyść (zaoszczędzenie czasu).</p>
<h2 id="wzorce-projektowe">Wzorce projektowe</h2>
<p>Gotowe, sprawdzone w praktyce szablony rozwiązań na często
pojawiające się problemy projektowe. Opisują rozwiązanie a nie są
implementacją rozwiązania.</p>
<p>Wzorce pozwalają na lepszą zrozumiałość, wydajność i niezawodność
kodu.</p>
<h3 id="kategorie-wzorców">Kategorie wzorców</h3>
<ul>
<li>Kreacyjne - związane z tworzeniem obiektów
<ul>
<li>Factory</li>
<li>Singleton</li>
<li>Prototype</li>
</ul></li>
<li>Strukturalne - związane ze strukturą aplikacji
<ul>
<li>Adapter</li>
<li>Decorator</li>
<li>Proxy</li>
</ul></li>
<li>Behawioralne - związane z wykonywanymi czynnościami
<ul>
<li>State</li>
<li>Strategy</li>
<li>Observer</li>
<li>Iterator</li>
</ul></li>
</ul>
<h3 id="materiały">Materiały</h3>
<ul>
<li><a href="https://refactoring.guru/">Refactoring Guru</a></li>
<li><a href="https://sourcemaking.com/design_patterns">Source
Making</a></li>
<li><a
href="https://www.goodreads.com/book/show/3735293-clean-code">Clean Code
- Robert C. Martin</a></li>
</ul>
<h2 id="wiarygodność-systemów">Wiarygodność systemów</h2>
<p>Wiarygodność (dependability) to pewność działania, która pozwala na
uzasadnione zaufanie do usług dostarczanych przez system.</p>
<h3 id="aspekty-wiarygodności">Aspekty wiarygodności</h3>
<ul>
<li>Dostępność (Availability) - gotowość do użycia</li>
<li>Niezawodność (Realiability) - ciągłość usług, wykonywanie
funkcjonalności w wymaganym czasie</li>
<li>Bezpieczeństwo (Safety) - unikanie katastrofalnych konsekwencji (np.
odblokowanie drzwi windy w razie awarii)</li>
<li>Zabezpieczenie (Security) - zapobieganie nieupoważnionemu dostępowi
do danych i operacji</li>
</ul>

        </main>
    </div>
    <div class="table-of-contents">
        <nav id="TOC" role="doc-toc">
<ul>
<li><a href="#wstęp-do-inżynierii-oprogramowania">Wstęp do inżynierii
oprogramowania</a>
<ul>
<li><a href="#metody-projektowania-programu">Metody projektowania
programu</a></li>
<li><a href="#paradygmaty-programowania">Paradygmaty programowania</a>
<ul>
<li><a href="#imperatywne">Imperatywne</a></li>
<li><a href="#deklaratywne">Deklaratywne</a></li>
</ul></li>
<li><a href="#paradygmaty-imperatywne">Paradygmaty imperatywne</a>
<ul>
<li><a href="#proceduralne">Proceduralne</a></li>
<li><a href="#obiektowe">Obiektowe</a></li>
</ul></li>
<li><a href="#paradygmaty-deklaratywne">Paradygmaty deklaratywne</a>
<ul>
<li><a href="#funkcyjne">Funkcyjne</a></li>
<li><a href="#logiczne">Logiczne</a></li>
<li><a href="#programowanie-sterowane-danymi-data-flow">Programowanie
sterowane danymi (data flow)</a></li>
</ul></li>
<li><a href="#inne-paradygmaty">Inne paradygmaty</a>
<ul>
<li><a href="#programowanie-zdarzeniowe-event-driven">Programowanie
zdarzeniowe (event-driven)</a></li>
<li><a href="#programowanie-współbieżne-concurrent">Programowanie
współbieżne (concurrent)</a></li>
<li><a href="#data-driven-programming">Data-driven programming</a></li>
<li><a href="#programowanie-aspektowe-aspect-oriented">Programowanie
aspektowe (aspect-oriented)</a></li>
</ul></li>
<li><a href="#podstawowe-założenia-oop">Podstawowe założenia OOP</a>
<ul>
<li><a href="#dziedziczenie">Dziedziczenie</a></li>
<li><a href="#abstrakcja">Abstrakcja</a></li>
<li><a href="#hermetyzacja-enkapsulacja">Hermetyzacja
(enkapsulacja)</a></li>
<li><a href="#polimorfizm">Polimorfizm</a></li>
</ul></li>
<li><a href="#data-oriented-design">Data-oriented design</a></li>
<li><a href="#refleksja">Refleksja</a>
<ul>
<li><a href="#możliwości-refleksji">Możliwości refleksji</a></li>
</ul></li>
<li><a href="#separacja-zagadnień-soc">Separacja zagadnień (SoC)</a>
<ul>
<li><a href="#zalety">Zalety</a></li>
<li><a href="#dotyczy">Dotyczy</a></li>
<li><a href="#problem-separacji-zagadnień">Problem separacji
zagadnień</a></li>
</ul></li>
<li><a href="#zasady-solid">Zasady SOLID</a>
<ul>
<li><a href="#single-responsibility-principle">Single Responsibility
Principle</a></li>
<li><a href="#open-closed-principle">Open-Closed Principle</a></li>
<li><a href="#liskov-substitution-principle">Liskov Substitution
Principle</a></li>
<li><a href="#interface-segregation-principle">Interface Segregation
Principle</a></li>
<li><a href="#dependency-inversion-principle">Dependency Inversion
Principle</a></li>
</ul></li>
<li><a href="#dry---dont-repeat-yourself">DRY - Don’t repeat
yourself</a>
<ul>
<li><a href="#realizacja-założeń-dry">Realizacja założeń DRY</a></li>
</ul></li>
<li><a href="#kiss---keep-it-simple-stupid">KISS - Keep It Simple,
Stupid</a></li>
<li><a href="#wzorce-projektowe">Wzorce projektowe</a>
<ul>
<li><a href="#kategorie-wzorców">Kategorie wzorców</a></li>
<li><a href="#materiały">Materiały</a></li>
</ul></li>
<li><a href="#wiarygodność-systemów">Wiarygodność systemów</a>
<ul>
<li><a href="#aspekty-wiarygodności">Aspekty wiarygodności</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
    </div>
</div>
</body>
</html>
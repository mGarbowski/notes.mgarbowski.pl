<!doctype html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>10-zlozonosc-obliczeniowa</title>
    <link rel="stylesheet" href="../style.css">

    <!--    Load mathjax from cdn to render latex equations-->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
<div class="prev-next-links">
    
    <div class="index-links-prev">
        <a href="08-funkcje-stos-pamiec-w-procesie.html">Poprzedni: 08-funkcje-stos-pamiec-w-procesie.html</a>
    </div>
    

    
    <div class="index-links-next">
        <a href="10-zlozonosc-obliczeniowa.html">Następny: 10-zlozonosc-obliczeniowa.html</a>
    </div>
    
    <div class="return-link">
        <a href="..">Powrót</a>
    </div>
</div>
<div class="container">
    <div class="index-links-wrapper">
        <h2>Podstawy informatyki i programowania</h2>
        <div class="index-links">
            <ul>
                
                <li><a href="00-wstep.html">00-wstep.html</a></li>
                
                <li><a href="01-podstawy.html">01-podstawy.html</a></li>
                
                <li><a href="02-architektura-komputera.html">02-architektura-komputera.html</a></li>
                
                <li><a href="03-arytmetyka-u2.pdf">03-arytmetyka-u2.pdf</a></li>
                
                <li><a href="03-liczby-calkowite.html">03-liczby-calkowite.html</a></li>
                
                <li><a href="04-liczby-rzeczywiste.html">04-liczby-rzeczywiste.html</a></li>
                
                <li><a href="05-znaki-i-napisy.html">05-znaki-i-napisy.html</a></li>
                
                <li><a href="06-algorytmy.html">06-algorytmy.html</a></li>
                
                <li><a href="07-przeplyw-sterowania.html">07-przeplyw-sterowania.html</a></li>
                
                <li><a href="08-funkcje-stos-pamiec-w-procesie.html">08-funkcje-stos-pamiec-w-procesie.html</a></li>
                
                <li><a href="09-wstep-do-inzynierii-oprogramowania.html">09-wstep-do-inzynierii-oprogramowania.html</a></li>
                
                <li><a href="10-zlozonosc-obliczeniowa.html">10-zlozonosc-obliczeniowa.html</a></li>
                
                <li><a href="11-lingwistyka-matematyczna.html">11-lingwistyka-matematyczna.html</a></li>
                
                <li><a href="powtorzenie-do-kolokwium-01.html">powtorzenie-do-kolokwium-01.html</a></li>
                
                <li><a href="powtorzenie-do-kolokwium-02.html">powtorzenie-do-kolokwium-02.html</a></li>
                
            </ul>
        </div>
    </div>
    <div class="content-wrapper">
        <main>
            <p>Jeśli strona była dla Ciebie pomocna, możesz wesprzeć mnie w jej utrzymaniu na <a href="https://buycoffee.to/mgarbowski">buycoffee.to/mgarbowski</a></p>
            <h1 id="złożoność-obliczeniowa">Złożoność obliczeniowa</h1>
<p>To że jedno rozwiązanie jest lepsze od drugiego może oznaczać, że
jest * Bardziej efektywne * szybsze * używa mniej zasobów (np. mniej
RAMu) * Bardziej skalowalne * może być zrównoleglone, przetwarzane naraz
przez kilka jednostek * Bardziej dokładne</p>
<h2 id="cechy-algorytmu">Cechy algorytmu</h2>
<p>Algorytm jest skończonym ciągiem instrukcji. Każda z nich musi być
zrozumiała i wykonalna dla realizującego. Musi rządzić się dobrze
określonymi regułami.</p>
<p>Powinien być ogólny - nie dla jednego konkretnego zestawu danych
tylko jak największego.</p>
<p>Liczba kroków algorytmu zależy od jego samego, ilości danych i
wartości danych. Liczba potrzebnych kroków powinna być skończona i
algorytm powinien się kiedyś zakończyć (własność stopu).</p>
<h2 id="złożoność">Złożoność</h2>
<p>Złożoność problemu / algorytmu to ilość zasobów konieczna do jego
rozwiązania / wykonania.</p>
<p>Złożoność problemu to nie to samo co złożoność algorytmu. Na
rozwiązanie jednego problemu może istnieć wiele algorytmów. Wtedy
złożoność problemu to najmniejsza ze złożoności dostępnych
algorytmów.</p>
<p>Więcej danych to nie zawsze więcej operacji - może nie trzeba
przeglądać całego zbioru.</p>
<p>Więcej operacji to nie zawsze więcej czasu - może da się wykorzystać
więcej zasobów i zrównnoleglić algorytm (np. na kilku rdzeniach na
raz)</p>
<h2 id="zapotrzebowanie-na-zasoby">Zapotrzebowanie na zasoby</h2>
<ul>
<li>Czas</li>
<li>Przestrzeń - pamięć operacyjna, przestrzeń dyskowa</li>
<li>Liczba potrzebnych operacji arytmetycznych, przekształceń</li>
<li>Dostęp do zewnętrznych urządzeń / systemów (sieć)</li>
</ul>
<h2 id="przeszukiwanie-liniowe-i-binarne">Przeszukiwanie liniowe i
binarne</h2>
<p>Przeszukiwanie liniowe - sprawdzanie po kolei każdego elementu w
ciągu, dopóki nie znajdzie się szukanego albo dojdzie do końca.
Złożoność liniowa O(n) - wydłużenie ciągu 2 razy -&gt; 2 razy więcej
operacji.</p>
<p>Przeszukiwanie binarne - dla uporządkowanego ciągu, metoda bisekcji.
Po sprawdzeniu jednego elementu wiadomo, że szukany będzie większy lub
mniejszy i jedną połowę ciągu można odrzucić. Złożoność logarytmiczna
O(log2(n)) - wydłużenie ciągu 2 razy -&gt; 1 operacja więcej.</p>
<h2 id="złożoność-czasowa-o">Złożoność czasowa O()</h2>
<p>Notacja dużego O nie podaje konkretnego czasu działania algorytmu,
ale charakter wpływu rozmiaru danych na czas wykonywania.</p>
<p>Ważny jest tylko rząd wielkości - <span class="math inline">\(O(3n^2
+ 4n + 1) = O(n^2)\)</span>. O(f(n)) mówi o rzędzie wielkości dla dużych
wartości n - asymptotycznie dla n dążącego do nieskończoności.</p>
<p>Jest jakiś punkt przegięcia po którym algorytm O(log(n)) będzie
lepszy od algorytmu O(n). Dla mniejszych danych, może bardziej opłacać
się użycie O(n).</p>
<p>Dwa algorytmy o złożoności liniowej O(n) mogą różnić się czasem
wykonywania (czynnik stały, wyraz wolny).</p>
<p>Przeszukiwanie liniowe O(n) z wykorzystaniem cache’y procesora, może
być dużo szybsze niż wyszukiwanie binarne i sięganie do pamięci po
drzewo binarne.</p>
<p>Może opłaca się posortować listę O(nlog(n)), żeby móc użyć szybszego
wyszukiwania binarnego O(log(n)) jeśli będzie się wyszukiwać
wielokrotnie.</p>
<h2 id="analiza-algorytmu">Analiza algorytmu</h2>
<p>Czas działania zależy nie tylko od liczności danych ale też wartości
i dostępności.</p>
<p>Rozpatruje się różne typy złożoności * W najgorszym wypadku
(worst-case) * W najlepszym wypadku (best-case) * Średnio
(average-case)</p>
<p>Dla przeszukiwania liniowego * worst-case -&gt; O(n) - przeszukanie
całej tablicy * average-case -&gt; O(n/2) = O(n) - w połowie tablicy *
best-case -&gt; O(1) - na pierwszej sprawdzonej pozycji</p>
<h2 id="złożoności"><a
href="https://www.bigocheatsheet.com/">Złożoności</a></h2>
<ul>
<li>stała (constant) - O(1)</li>
<li>logarytmiczna - O(log(n))</li>
<li>liniowa - O(n)</li>
<li>wielomianowa (polynomial) - O(n^2), O(n^3), O(n^k)</li>
<li>wykładnicza (exponential) - O(k^n), O(k<sup>n</sup>n), O(n!)</li>
</ul>
<p>O(n) nie musi oznaczać sukcesu np. jeśli zbiór danych jest
odpowiednio duży albo jeśli algorytm nie jest skalowalny.</p>
<figure>
<img
src="https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fera86.github.io%2Fassets%2Fimages%2Fposts%2Fbig-o-chart.png&amp;f=1&amp;nofb=1&amp;ipt=b8008c71ec5645f45ad07f49fa16e03c720d5ba61f937f3f131a7cdf824c7ee9&amp;ipo=images"
alt="wykres złożoności" />
<figcaption aria-hidden="true">wykres złożoności</figcaption>
</figure>
<h2 id="luka-algorytmiczna">Luka algorytmiczna</h2>
<p>Luka algorytmiczna - zakres złożoności ograniczony z dołu przez
formalne dowody matematyczne, że nie może istnieć lepszy algorytm i
ograniczony z góry przez najlepszy znany algorytm.</p>
<p>Jeśli luka nie istnieje to problem jest algorytmicznie zamknięty. Np.
na przeszukiwanie nieuporządkowanej tablicy - udowodniono, że złożoność
nie może być lepsza niż O(n) i jest znany algorytm O(n).</p>
<h2 id="struktury-danych">Struktury danych</h2>
<p>Struktury danych różnią się złożonością czasową i przestrzenną. Spsób
używania danych powinien determinować w jakiej strukturze należy je
przechowywać.</p>
<figure>
<img src="https://he-s3.s3.amazonaws.com/media/uploads/c14cb1f.JPG"
alt="Tabela złożoności dla struktur danych" />
<figcaption aria-hidden="true">Tabela złożoności dla struktur
danych</figcaption>
</figure>
<h2 id="problem-komiwojażera">Problem komiwojażera</h2>
<p>W rozwiązaniu problemu komiwojażera sprawdzenie jednej z możliwych
ścieżek jest problemem wielomianowym O(n), ale jest wykładniczo O(n!)
dużo kombinacji ścieżek (eksplozja wykładnicza).</p>
<p>Nie ma reguły co do wyboru ścieżki, można trafić na najlepszą w
pierwszej permutacji albo równie dobrze w ostatniej - wybór jest
niedeterministyczny.</p>
<h2 id="problemy-p-i-np">Problemy P i NP</h2>
<p>Problemy P (Polynomial) - Łatwe do rozwiązania, rozwiązania łatwe do
zweryfikowania w czasie wielomianowym.</p>
<p>Problemy NP (Nondeterministic Polynomial) - rozwiązanie łatwe do
zweryfikowania w czasie wielomianowym. Np problemy decyzyjne
wykładnicze: problem komiwojażera, porównywanie grafów, problem
plecakowy, kolorowanie mapy.</p>
<p>Klasa problemów P jest podzbiorem NP <span class="math inline">\(P
\subseteq NP\)</span></p>
<p>Nie wiadomo czy <span class="math inline">\(P=NP\)</span>, dowód
miałby poważne konsekwencje.</p>
<h2 id="dokładność">Dokładność</h2>
<p>Czasami wystarczy rozwiązanie akceptowalne, które można znaleźć w
krótkim czasie a nie idealne.</p>

        </main>
    </div>
    <div class="table-of-contents">
        <nav id="TOC" role="doc-toc">
<ul>
<li><a href="#złożoność-obliczeniowa">Złożoność obliczeniowa</a>
<ul>
<li><a href="#cechy-algorytmu">Cechy algorytmu</a></li>
<li><a href="#złożoność">Złożoność</a></li>
<li><a href="#zapotrzebowanie-na-zasoby">Zapotrzebowanie na
zasoby</a></li>
<li><a href="#przeszukiwanie-liniowe-i-binarne">Przeszukiwanie liniowe i
binarne</a></li>
<li><a href="#złożoność-czasowa-o">Złożoność czasowa O()</a></li>
<li><a href="#analiza-algorytmu">Analiza algorytmu</a></li>
<li><a href="#złożoności"><span>Złożoności</span></a></li>
<li><a href="#luka-algorytmiczna">Luka algorytmiczna</a></li>
<li><a href="#struktury-danych">Struktury danych</a></li>
<li><a href="#problem-komiwojażera">Problem komiwojażera</a></li>
<li><a href="#problemy-p-i-np">Problemy P i NP</a></li>
<li><a href="#dokładność">Dokładność</a></li>
</ul></li>
</ul>
</nav>
    </div>
</div>
</body>
</html>
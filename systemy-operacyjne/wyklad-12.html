<!doctype html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>wyklad-12</title>
    <link rel="stylesheet" href="../style.css">

    <!--    Load mathjax from cdn to render latex equations-->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
<div class="prev-next-links">
    
    <div class="index-links-prev">
        <a href="wyklad-11.html">Poprzedni: wyklad-11.html</a>
    </div>
    

    
    <div class="index-links-next">
        <a href="wyklad-13.html">Następny: wyklad-13.html</a>
    </div>
    
    <div class="return-link">
        <a href="..">Powrót</a>
    </div>
</div>
<div class="container">
    <div class="index-links-wrapper">
        <h2>Systemy operacyjne</h2>
        <div class="index-links">
            <ul>
                
                <li><a href="powtorzenie-do-kolokwium.html">powtorzenie-do-kolokwium.html</a></li>
                
                <li><a href="wyklad-01.html">wyklad-01.html</a></li>
                
                <li><a href="wyklad-02.html">wyklad-02.html</a></li>
                
                <li><a href="wyklad-03.html">wyklad-03.html</a></li>
                
                <li><a href="wyklad-04.html">wyklad-04.html</a></li>
                
                <li><a href="wyklad-05.html">wyklad-05.html</a></li>
                
                <li><a href="wyklad-06.html">wyklad-06.html</a></li>
                
                <li><a href="wyklad-07.html">wyklad-07.html</a></li>
                
                <li><a href="wyklad-08.html">wyklad-08.html</a></li>
                
                <li><a href="wyklad-09.html">wyklad-09.html</a></li>
                
                <li><a href="wyklad-10.html">wyklad-10.html</a></li>
                
                <li><a href="wyklad-11.html">wyklad-11.html</a></li>
                
                <li><a href="wyklad-12.html">wyklad-12.html</a></li>
                
                <li><a href="wyklad-13.html">wyklad-13.html</a></li>
                
                <li><a href="wyklad-14.html">wyklad-14.html</a></li>
                
            </ul>
        </div>
    </div>
    <div class="content-wrapper">
        <main>
            <p>Jeśli strona była dla Ciebie pomocna, możesz wesprzeć mnie w jej utrzymaniu na <a href="https://buycoffee.to/mgarbowski">buycoffee.to/mgarbowski</a></p>
            <h1 id="section">(2024-01-09)</h1>
<h2 id="komunikaty">Komunikaty</h2>
<p>W środowisku rozproszonym wszystkie wymienione wcześniej metody są
bezużyteczne bo nie ma dzielonej pamięci. Jedyny dostępny mechanizm to
przekazywanie komunikatów.</p>
<p>Komunikaty można wykorzystać na potrzeby synchronizacji</p>
<p>Oparte na dwóch wywołaniach systemowych
<code>send(destination, &amp;message)</code> i
<code>receive(source, &amp;message)</code>. Nadaje się do komunikacji
sieciowej bez wspólnej pamięci. Tworzy się analogiczny bufor ze zbioru
komunikatów.</p>
<p><code>send</code> jest nieblokujące, a <code>receive</code> jest
blokuące (proces zawiesza się dopóki nie dojdzie komunikat)</p>
<ul>
<li>Konsument wysyła producentowi wiele pustych komunikatów</li>
<li>Producent najpierw odbiera (zawiesza się w oczekiwaniu) a potem
odsyła zapełnioną wiadomość</li>
<li>Konsument odbiera (zawiesza się w oczekiwaniu) pełną wiadomość i
odsyła pustą</li>
</ul>
<p>Kontrola przepływu - wydajność jest ograniczona do szybkości
wolniejszego z dwóch procesów, producent prześle treść dopiero jak
dostanie pusty komunikat - gwarancja że nie będzie przepełnienia.
Szybszy producent nie zaleje wolnego konsumenta komunikatami</p>
<h2 id="problem-ucztujących-filozofów">Problem ucztujących
filozofów</h2>
<p>Jeśli proces wszedł do sekcji krytycznej, opuścił jakiś semafor i
poszedł spać to ten semafor będzie opuszczony - może nastąpić blokada,
jeśli inny proces czeka na semafor, a ten który opuścił nie zostanie
obudzony i go nie podniesie</p>
<p>N filozofów przy stole i N widelców pomiędzy nimi, filozof musi wziąć
2 widelce, żeby móc jeść, filozof może jeść lub myśleć</p>
<p>Wzajemne wykluczanie w dostępie do stołu (mutex) - nie będzie blokady
ale to nieefektywne</p>
<p>Semafor zainicjowany wartością N-1 - nie będzie blokady bo nie mogą
wszyscy złapać za prawy widelec (rozwiązanie z kelnerem)</p>
<p>Trzeba przeformułować zadanie - wewnątrz sekcji krytycznej tylko
operacja up i sprawdzanie wyjątków, bezwarunkowe opuszczenie semafora na
końcu sekcji krytycznej (pytanie czy nie zatrzymywać procesu zamiast
pytania czy zatrzymać proces) Semafor podnosi się z wyprzedzeniem</p>
<p>Pośredni stan stan hungry między thinking i eating mutex do
organizacji sekcji krytycznej i tablica semaforów (po 1 dla każdego
filozofa), inicjowane wartością 0 W sekcji krytycznej ustawia stan na
hungry i sprawdza czy może być nie zatrzymany (jeśli może to z
wyprzedzeniem podnosi semafor) Wykonuje down na swoich semaforze (jeśli
już może jeść to zaczyna a jeśli nie to się zawiesza) Odłożenie widelców
sprawdza czy sąsiedzi mogą zacząć jeść i podnosi ich semafory jeśli
tak</p>
<p>Warunkowe podniesienie semafora z wyprzedzniem i bezwarunkowe
opuszczenie poza sekcją krytyczną - wzorzec synchronizacyjny, dobry do
wielu problemów</p>
<p>Istotą jest unkikanie wywołania down w sekcji krytycznej</p>
<p>Na egzamin * synchronizacja w problemie 5 filozofów * jak poradzić
sobie z sytuacją kiedy potencjalnie musimy usypiać proces po sprawdzeniu
warunku w sekcji krytycznej</p>
<h2 id="problem-czytelników-i-pisarzy">Problem czytelników i
pisarzy</h2>
<p>Problem dostępu do rekordu bazy danych</p>
<p>Można rozwiązać przez sekcję krytyczną ale to nie będzie wydajne
Chcemy wzajemnego wykluczania tylko w przypadku konfliktów Wiele
odczytów tego samego rekordu nie powinno się nawzajem blokować</p>
<p>mutex chroni dostęp do licznika czytelników może wejść wielu
czytelników na raz pisarz może wejść tylko jeśli nie ma czytelników Jest
problem bo odczyty mogą zablokować aktualizację (ale nie będzie
blokady)</p>
<p>Można użyć analogicznego mechanizmu żeby blokować nowych czytelników
kieyd przychodzi nowy pisarz semafor r blokuje nowo przychodzących
czytelników tylko 1 czytelnik może zatrzymać się na r (od tego jest
semafor m) - statystycznie lepsza szansa że to pisarz zostanie wznowiony
conajwyżej 1 czytelnik może rywalizować z pisarzami</p>

        </main>
    </div>
    <div class="table-of-contents">
        <nav id="TOC" role="doc-toc">
<ul>
<li><a href="#section">(2024-01-09)</a>
<ul>
<li><a href="#komunikaty">Komunikaty</a></li>
<li><a href="#problem-ucztujących-filozofów">Problem ucztujących
filozofów</a></li>
<li><a href="#problem-czytelników-i-pisarzy">Problem czytelników i
pisarzy</a></li>
</ul></li>
</ul>
</nav>
    </div>
</div>
</body>
</html>